#!/bin/sh

set -e
unset GREP_OPTIONS
export IFS="$(printf "\n\b")"

APT_DIR="/"
eval $(apt-config shell APT_DIR Dir)

MASTER_KEYRING='&keyring-master-filename;'
eval $(apt-config shell MASTER_KEYRING APT::Key::MasterKeyring)
ARCHIVE_KEYRING='&keyring-filename;'
eval $(apt-config shell ARCHIVE_KEYRING APT::Key::ArchiveKeyring)
REMOVED_KEYS='&keyring-removed-filename;'
eval $(apt-config shell REMOVED_KEYS APT::Key::RemovedKeys)
ARCHIVE_KEYRING_URI='&keyring-uri;'
eval $(apt-config shell ARCHIVE_KEYRING_URI APT::Key::ArchiveKeyringURI)

aptkey_echo() { echo "$@"; }

requires_root() {
	if [ "$(id -u)" -ne 0 ]; then
		echo >&2 "ERROR: This command can only be used by root."
		exit 1
	fi
}

get_fingerprints_of_keyring() {
    aptkey_execute "$GPG_SH" --keyring "$1" --with-colons --fingerprint | while read publine; do
	# search for a public key
	if [ "${publine%%:*}" != 'pub' ]; then continue; fi
	# search for the associated fingerprint (should be the very next line)
	while read fprline; do
	   if [ "${fprline%%:*}" = 'sub' ]; then break; # should never happen
	   elif [ "${fprline%%:*}" != 'fpr' ]; then continue; fi
	   echo "$fprline" | cut -d':' -f 10
	done
	# order in the keyring shouldn't be important
    done | sort
}

add_keys_with_verify_against_master_keyring() {
    ADD_KEYRING=$1
    MASTER=$2

    if [ ! -f "$ADD_KEYRING" ]; then
	echo >&2 "ERROR: '$ADD_KEYRING' not found"
	return
    fi
    if [ ! -f "$MASTER" ]; then
	echo >&2 "ERROR: '$MASTER' not found"
	return
    fi

    # when adding new keys, make sure that the archive-master-keyring
    # is honored. so:
    #   all keys that are exported must have a valid signature
    #   from a key in the $distro-master-keyring
    add_keys="$(get_fingerprints_of_keyring "$ADD_KEYRING")"
    all_add_keys=`aptkey_execute "$GPG_SH" --keyring "$ADD_KEYRING" --with-colons --list-keys | grep ^[ps]ub | cut -d: -f5`
    master_keys=`aptkey_execute "$GPG_SH" --keyring "$MASTER" --with-colons --list-keys | grep ^pub | cut -d: -f5`

    # ensure there are no colisions LP: #857472
    for all_add_key in $all_add_keys; do
	for master_key in $master_keys; do
            if [ "$all_add_key" = "$master_key" ]; then
                echo >&2 "Keyid collision for '$all_add_key' detected, operation aborted"
                return 1
            fi
        done
    done

    for add_key in $add_keys; do
        # export the add keyring one-by-one
	local TMP_KEYRING="${GPGHOMEDIR}/tmp-keyring.gpg"
	aptkey_execute "$GPG_SH" --batch --yes --keyring "$ADD_KEYRING" --output "$TMP_KEYRING" --export "$add_key"
	if ! aptkey_execute "$GPG_SH" --batch --yes --keyring "$TMP_KEYRING" --import "$MASTER" > "${GPGHOMEDIR}/gpgoutput.log" 2>&1; then
	    cat >&2 "${GPGHOMEDIR}/gpgoutput.log"
	    false
	fi
	# check if signed with the master key and only add in this case
	ADDED=0
	for master_key in $master_keys; do
	    if aptkey_execute "$GPG_SH" --keyring "$TMP_KEYRING" --check-sigs --with-colons "$add_key" \
	       | grep '^sig:!:' | cut -d: -f5 | grep -q "$master_key"; then
		aptkey_execute "$GPG_SH" --batch --yes --keyring "$ADD_KEYRING" --export "$add_key" \
		   | aptkey_execute "$GPG" --batch --yes --import
		ADDED=1
	    fi
	done
	if [ $ADDED = 0 ]; then
	    echo >&2 "Key '$add_key' not added. It is not signed with a master key"
	fi
	rm -f "${TMP_KEYRING}"
    done
}

# update the current archive signing keyring from a network URI
# the archive-keyring keys needs to be signed with the master key
# (otherwise it does not make sense from a security POV)
net_update() {
    # Disabled for now as code is insecure (LP: #1013639 (and 857472, 1013128))
    APT_KEY_NET_UPDATE_ENABLED=""
    eval $(apt-config shell APT_KEY_NET_UPDATE_ENABLED APT::Key::Net-Update-Enabled)
    if [ -z "$APT_KEY_NET_UPDATE_ENABLED" ]; then
        exit 1
    fi

    if [ -z "$ARCHIVE_KEYRING_URI" ]; then
	echo >&2 "ERROR: Your distribution is not supported in net-update as no uri for the archive-keyring is set"
	exit 1
    fi
    # in theory we would need to depend on wget for this, but this feature
    # isn't useable in debian anyway as we have no keyring uri nor a master key
    if ! which wget >/dev/null 2>&1; then
	echo >&2 "ERROR: an installed wget is required for a network-based update"
	exit 1
    fi
    if [ ! -d "${APT_DIR}/var/lib/apt/keyrings" ]; then
	mkdir -p "${APT_DIR}/var/lib/apt/keyrings"
    fi
    keyring="${APT_DIR}/var/lib/apt/keyrings/$(basename "$ARCHIVE_KEYRING_URI")"
    old_mtime=0
    if [ -e $keyring ]; then
	old_mtime=$(stat -c %Y $keyring)
    fi
    (cd  "${APT_DIR}/var/lib/apt/keyrings"; wget --timeout=90 -q -N "$ARCHIVE_KEYRING_URI")
    if [ ! -e "$keyring" ]; then
	return
    fi
    new_mtime=$(stat -c %Y "$keyring")
    if [ $new_mtime -ne $old_mtime ]; then
	aptkey_echo "Checking for new archive signing keys now"
	add_keys_with_verify_against_master_keyring "$keyring" "$MASTER_KEYRING"
    fi
}

update() {
    if [ ! -f "$ARCHIVE_KEYRING" ]; then
	echo >&2 "ERROR: Can't find the archive-keyring"
	echo >&2 "Is the &keyring-package; package installed?"
	exit 1
    fi

    # add new keys from the package;

    # we do not use add_keys_with_verify_against_master_keyring here,
    # because "update" is run on regular package updates.  A
    # attacker might as well replace the master-archive-keyring file
    # in the package and add his own keys. so this check wouldn't
    # add any security. we *need* this check on net-update though
    import_keyring_into_keyring "$ARCHIVE_KEYRING" '' && cat "${GPGHOMEDIR}/gpgoutput.log"

    if [ -r "$REMOVED_KEYS" ]; then
	# remove no-longer supported/used keys
	get_fingerprints_of_keyring "$REMOVED_KEYS" | while read key; do
	    foreach_keyring_do 'remove_key_from_keyring' "$key"
	done
    else
	echo >&2 "Warning: removed keys keyring  $REMOVED_KEYS missing or not readable"
    fi
}

remove_key_from_keyring() {
    local KEYRINGFILE="$1"
    shift
    # non-existent keyrings have by definition no keys
    if [ ! -e "$KEYRINGFILE" ]; then
       return
    fi

    for KEY in "$@"; do
	local FINGERPRINTS="${GPGHOMEDIR}/keyringfile.keylst"
	get_fingerprints_of_keyring "$KEYRINGFILE" > "$FINGERPRINTS"
	# check if the key is in this keyring
	if ! grep -iq "^[0-9A-F]*${KEY}$" "$FINGERPRINTS"; then
	    continue
	fi
	if [ ! -w "$KEYRINGFILE" ]; then
	    echo >&2 "Key ${KEY} is in keyring ${KEYRINGFILE}, but can't be removed as it is read only."
	    continue
	fi
	# check if it is the only key in the keyring and if so remove the keyring altogether
	if [ '1' = "$(uniq "$FINGERPRINTS" | wc -l)" ]; then
	    mv -f "$KEYRINGFILE" "${KEYRINGFILE}~" # behave like gpg
	    return
	fi
	# we can't just modify pointed to files as these might be in /usr or something
	local REALTARGET
	if [ -L "$KEYRINGFILE" ]; then
	    REALTARGET="$(readlink -f "$KEYRINGFILE")"
	    mv -f "$KEYRINGFILE" "${KEYRINGFILE}.dpkg-tmp"
	    cp -a "$REALTARGET" "$KEYRINGFILE"
	fi
	# delete the key from the keyring
	aptkey_execute "$GPG_SH" --keyring "$KEYRINGFILE" --batch --delete-keys --yes "$KEY"
	if [ -n "$REALTARGET" ]; then
	    # the real backup is the old link, not the copy we made
	    mv -f "${KEYRINGFILE}.dpkg-tmp" "${KEYRINGFILE}~"
	fi
    done
}

foreach_keyring_do() {
   local ACTION="$1"
   shift
   # if a --keyring was given, just work on this one
   if [ -n "$FORCED_KEYRING" ]; then
	$ACTION "$FORCED_KEYRING" "$@"
   else
	# otherwise all known keyrings are up for inspection
	if [ -s "$TRUSTEDFILE" ]; then
	    $ACTION "$TRUSTEDFILE" "$@"
	fi
	local TRUSTEDPARTS="/etc/apt/trusted.gpg.d"
	eval $(apt-config shell TRUSTEDPARTS Dir::Etc::TrustedParts/d)
	if [ -d "$TRUSTEDPARTS" ]; then
	    # strip / suffix as gpg will double-slash in that case (#665411)
	    local STRIPPED_TRUSTEDPARTS="${TRUSTEDPARTS%/}"
	    if [ "${STRIPPED_TRUSTEDPARTS}/" = "$TRUSTEDPARTS" ]; then
		TRUSTEDPARTS="$STRIPPED_TRUSTEDPARTS"
	    fi
	    for trusted in $(run-parts --list "$TRUSTEDPARTS" --regex '^.*\.gpg$'); do
		if [ -s "$trusted" ]; then
		    $ACTION "$trusted" "$@"
		fi
	    done
	fi
   fi
}

run_cmd_on_keyring() {
    local KEYRINGFILE="$1"
    shift
    # fingerprint and co will fail if key isn't in this keyring
    aptkey_execute "$GPG_SH" --keyring "$KEYRINGFILE" --batch "$@" 2>/dev/null || true
}

import_keyring_into_keyring() {
    local FROM="${1:-${GPGHOMEDIR}/pubring.gpg}"
    local TO="${2:-${GPGHOMEDIR}/pubring.gpg}"
    shift 2
    rm -f "${GPGHOMEDIR}/gpgoutput.log"
    # the idea is simple: We take keys from one keyring and copy it to another
    # we do this with so many checks in between to ensure that WE control the
    # creation, so we know that the (potentially) created $TO keyring is a
    # simple keyring rather than a keybox as gpg2 would create it which in turn
    # can't be read by gpgv.
    # BEWARE: This is designed more in the way to work with the current
    # callers, than to have a well defined it would be easy to add new callers to.
    if [ ! -s "$TO" ]; then
	if [ -s "$FROM" ]; then
	    if [ -z "$2" ]; then
		if ! aptkey_execute "$GPG_SH" --keyring "$FROM" --export ${1:+"$1"} > "$TO" 2> "${GPGHOMEDIR}/gpgoutput.log"; then
		    cat >&2 "${GPGHOMEDIR}/gpgoutput.log"
		    false
		else
		    chmod 0644 -- "$TO"
		fi
	    else
		create_new_keyring "$TO"
	    fi
	else
	    create_new_keyring "$TO"
	fi
    elif [ -s "$FROM" ]; then
	local EXPORTLIMIT="$1"
	if [ -n "$1$2" ]; then shift; fi
	if ! aptkey_execute "$GPG_SH" --keyring "$FROM" --export ${EXPORTLIMIT:+"$EXPORTLIMIT"} \
	   | aptkey_execute "$GPG_SH" --keyring "$TO" --batch --import "$@" > "${GPGHOMEDIR}/gpgoutput.log" 2>&1; then
	    cat >&2 "${GPGHOMEDIR}/gpgoutput.log"
	    false
	fi
    fi
}

merge_all_trusted_keyrings_into_pubring() {
    # does the same as:
    # foreach_keyring_do 'import_keys_from_keyring' "${GPGHOMEDIR}/pubring.gpg"
    # but without using gpg, just cat and find
    local PUBRING="${GPGHOMEDIR}/pubring.gpg"
    # if a --keyring was given, just use this one
    if [ -n "$FORCED_KEYRING" ]; then
	if [ -s "$FORCED_KEYRING" ]; then
	    cp --dereference "$FORCED_KEYRING" "$PUBRING"
	fi
    else
	# otherwise all known keyrings are merged
	local TRUSTEDPARTS="/etc/apt/trusted.gpg.d"
	eval $(apt-config shell TRUSTEDPARTS Dir::Etc::TrustedParts/d)
	if [ -d "$TRUSTEDPARTS" ]; then
	    # ignore errors mostly for non-existing $TRUSTEDFILE
	    {
	       cat "$TRUSTEDFILE" || true
	       for parts in $(find -L "$TRUSTEDPARTS" -type f -name '*.gpg'); do
		  cat "$parts" || true
	       done
	    } > "$PUBRING" 2>/dev/null
	elif [ -s "$TRUSTEDFILE" ]; then
	    cp --dereference "$TRUSTEDFILE" "$PUBRING"
	fi
    fi

    if [ ! -s "$PUBRING" ]; then
	touch "$PUBRING"
    fi
}

import_keys_from_keyring() {
    import_keyring_into_keyring "$1" "$2"
}

merge_keys_into_keyrings() {
    import_keyring_into_keyring "$2" "$1" '' --import-options 'merge-only'
}

merge_back_changes() {
    if [ -n "$FORCED_KEYRING" ]; then
	# if the keyring was forced merge is already done
	return
    fi
    if [ -s "${GPGHOMEDIR}/pubring.gpg" ]; then
	# merge all updated keys
	foreach_keyring_do 'merge_keys_into_keyrings' "${GPGHOMEDIR}/pubring.gpg"
    fi
    # look for keys which were added or removed
    get_fingerprints_of_keyring "${GPGHOMEDIR}/pubring.orig.gpg" > "${GPGHOMEDIR}/pubring.orig.keylst"
    get_fingerprints_of_keyring "${GPGHOMEDIR}/pubring.gpg" > "${GPGHOMEDIR}/pubring.keylst"
    comm -3 "${GPGHOMEDIR}/pubring.keylst" "${GPGHOMEDIR}/pubring.orig.keylst" > "${GPGHOMEDIR}/pubring.diff"
    # key isn't part of new keyring, so remove
    cut -f 2 "${GPGHOMEDIR}/pubring.diff" | while read key; do
	if [ -z "$key" ]; then continue; fi
	foreach_keyring_do 'remove_key_from_keyring' "$key"
    done
    # key is only part of new keyring, so we need to import it
    cut -f 1 "${GPGHOMEDIR}/pubring.diff" | while read key; do
	if [ -z "$key" ]; then continue; fi
	import_keyring_into_keyring '' "$TRUSTEDFILE" "$key"
    done
}

setup_merged_keyring() {
    if [ -n "$FORCED_KEYID" ]; then
	merge_all_trusted_keyrings_into_pubring
	FORCED_KEYRING="${GPGHOMEDIR}/forcedkeyid.gpg"
	TRUSTEDFILE="${FORCED_KEYRING}"
	echo "#!/bin/sh
exec sh \"${GPG}\" --keyring \"${TRUSTEDFILE}\" \"\$@\"" > "${GPGHOMEDIR}/gpg.1.sh"
	GPG="${GPGHOMEDIR}/gpg.1.sh"
	# ignore error as this "just" means we haven't found the forced keyid and the keyring will be empty
	import_keyring_into_keyring '' "$TRUSTEDFILE" "$FORCED_KEYID" || true
    elif [ -z "$FORCED_KEYRING" ]; then
	merge_all_trusted_keyrings_into_pubring
	if [ -r "${GPGHOMEDIR}/pubring.gpg" ]; then
	    cp -a "${GPGHOMEDIR}/pubring.gpg" "${GPGHOMEDIR}/pubring.orig.gpg"
	else
	   touch "${GPGHOMEDIR}/pubring.gpg" "${GPGHOMEDIR}/pubring.orig.gpg"
	fi
	echo "#!/bin/sh
exec sh \"${GPG}\" --keyring \"${GPGHOMEDIR}/pubring.gpg\" \"\$@\"" > "${GPGHOMEDIR}/gpg.1.sh"
	GPG="${GPGHOMEDIR}/gpg.1.sh"
    else
	create_new_keyring "$TRUSTEDFILE"
	echo "#!/bin/sh
exec sh \"${GPG}\" --keyring \"${TRUSTEDFILE}\" \"\$@\"" > "${GPGHOMEDIR}/gpg.1.sh"
	GPG="${GPGHOMEDIR}/gpg.1.sh"
    fi
}

create_new_keyring() {
    # gpg defaults to mode 0600 for new keyrings. Create one with 0644 instead.
    if ! [ -e "$TRUSTEDFILE" ]; then
	if [ -w "$(dirname "$TRUSTEDFILE")" ]; then
	    touch -- "$TRUSTEDFILE"
	    chmod 0644 -- "$TRUSTEDFILE"
	fi
    fi
}

aptkey_execute() { sh "$@"; }

usage() {
    echo "Usage: apt-key [--keyring file] [command] [arguments]"
    echo
    echo "Manage apt's list of trusted keys"
    echo
    echo "  apt-key add <file>          - add the key contained in <file> ('-' for stdin)"
    echo "  apt-key del <keyid>         - remove the key <keyid>"
    echo "  apt-key export <keyid>      - output the key <keyid>"
    echo "  apt-key exportall           - output all trusted keys"
    echo "  apt-key update              - update keys using the keyring package"
    echo "  apt-key net-update          - update keys using the network"
    echo "  apt-key list                - list keys"
    echo "  apt-key finger              - list fingerprints"
    echo "  apt-key adv                 - pass advanced options to gpg (download key)"
    echo
    echo "If no specific keyring file is given the command applies to all keyring files."
}

while [ -n "$1" ]; do
   case "$1" in
      --keyring)
	 shift
	 TRUSTEDFILE="$1"
	 FORCED_KEYRING="$1"
	 ;;
      --keyid)
	 shift
	 FORCED_KEYID="$1"
	 ;;
      --secret-keyring)
	 shift
	 FORCED_SECRET_KEYRING="$1"
	 ;;
      --readonly)
	 merge_back_changes() { true; }
	 create_new_keyring() { if [ ! -r "$FORCED_KEYRING" ]; then TRUSTEDFILE='/dev/null'; FORCED_KEYRING="$TRUSTEDFILE"; fi; }
	 ;;
      --fakeroot)
	 requires_root() { true; }
	 ;;
      --quiet)
	 aptkey_echo() { true; }
	 ;;
      --debug1)
	 # some cmds like finger redirect stderr to /dev/null …
	aptkey_execute() { echo 'EXEC:' "$@"; sh "$@"; }
	;;
      --debug2)
	 # … other more complicated ones pipe gpg into gpg.
	aptkey_execute() { echo >&2 'EXEC:' "$@"; sh "$@"; }
	;;
      --*)
	 echo >&2 "Unknown option: $1"
	 usage
	 exit 1;;
      *)
	 break;;
   esac
   shift
done

if [ -z "$TRUSTEDFILE" ]; then
   TRUSTEDFILE="/etc/apt/trusted.gpg"
   eval $(apt-config shell TRUSTEDFILE Apt::GPGV::TrustedKeyring)
   eval $(apt-config shell TRUSTEDFILE Dir::Etc::Trusted/f)
fi

command="$1"
if [ -z "$command" ]; then
    usage
    exit 1
fi
shift

create_gpg_home() {
    # gpg needs (in different versions more or less) files to function correctly,
    # so we give it its own homedir and generate some valid content for it later on
    if [ -n "$TMPDIR" ]; then
	# tmpdir is a directory and current user has rwx access to it
	# same tests as in apt-pkg/contrib/fileutl.cc GetTempDir()
	if [ ! -d "$TMPDIR" ] || [ ! -r "$TMPDIR" ] || [ ! -w "$TMPDIR" ] || [ ! -x "$TMPDIR" ]; then
	    unset TMPDIR
	fi
    fi
    GPGHOMEDIR="$(mktemp -d)"
    CURRENTTRAP="${CURRENTTRAP} rm -rf '${GPGHOMEDIR}';"
    trap "${CURRENTTRAP}" 0 HUP INT QUIT ILL ABRT FPE SEGV PIPE TERM
    chmod 700 "$GPGHOMEDIR"
}

prepare_gpg_home() {
    eval $(apt-config shell GPG_EXE Apt::Key::gpgcommand)

    if [ -n "$GPG_EXE" ] && which "$GPG_EXE" >/dev/null 2>&1; then
	true
    elif which gpg >/dev/null 2>&1; then
	GPG_EXE="gpg"
    elif which gpg2 >/dev/null 2>&1; then
	GPG_EXE="gpg2"
    else
	echo >&2 "Error: gnupg or gnupg2 do not seem to be installed,"
	echo >&2 "Error: but apt-key requires gnupg or gnupg2 for this operation."
	echo >&2
	exit 255
    fi

    create_gpg_home

    # We don't use a secret keyring, of course, but gpg panics and
    # implodes if there isn't one available - and writeable for imports
    SECRETKEYRING="${GPGHOMEDIR}/secring.gpg"
    touch "$SECRETKEYRING"

    # create the trustdb with an (empty) dummy keyring
    # older gpgs required it, newer gpgs even warn that it isn't needed,
    # but require it nonetheless for some commands, so we just play safe
    # here for the foreseeable future and create a dummy one
    if ! "$GPG_EXE" --ignore-time-conflict --no-options --no-default-keyring \
       --homedir "$GPGHOMEDIR" --quiet --check-trustdb --keyring "$SECRETKEYRING" >"${GPGHOMEDIR}/gpgoutput.log" 2>&1; then
       cat >&2 "${GPGHOMEDIR}/gpgoutput.log"
       false
    fi
    # tell gpg that it shouldn't try to maintain a trustdb file
    echo "#!/bin/sh
exec \"${GPG_EXE}\" --ignore-time-conflict --no-options --no-default-keyring \\
   --homedir \"${GPGHOMEDIR}\" --no-auto-check-trustdb --trust-model always \"\$@\"" > "${GPGHOMEDIR}/gpg.0.sh"
    GPG_SH="${GPGHOMEDIR}/gpg.0.sh"
    GPG="$GPG_SH"

    # for advanced operations, we might really need a secret keyring after all
    if [ -n "$FORCED_SECRET_KEYRING" ] && [ -r "$FORCED_SECRET_KEYRING" ]; then
	rm -f "$SECRETKEYRING"
	cp -a "$FORCED_SECRET_KEYRING" "$SECRETKEYRING"
    fi

    # older gpg versions need a secring file, but newer versions take it as
    # a hint to start a migration from earlier versions. The file is empty
    # anyhow, so nothing actually happens, but its three lines of output
    # nobody expects to see in apt-key context, so trigger it in silence
    echo -n | aptkey_execute "$GPG" --batch --import >/dev/null 2>&1 || true
}

if [ "$command" != 'help' ] && [ "$command" != 'verify' ]; then
    prepare_gpg_home
fi

case "$command" in
    add)
	requires_root
	setup_merged_keyring
	aptkey_execute "$GPG" --quiet --batch --import "$@"
	merge_back_changes
	aptkey_echo "OK"
        ;;
    del|rm|remove)
	requires_root
	foreach_keyring_do 'remove_key_from_keyring' "$@"
	aptkey_echo "OK"
        ;;
    update)
	requires_root
	setup_merged_keyring
	update
	merge_back_changes
	;;
    net-update)
	requires_root
	setup_merged_keyring
	net_update
	merge_back_changes
	;;
    list)
	foreach_keyring_do 'run_cmd_on_keyring' --list-keys "$@"
	;;
    finger*)
	foreach_keyring_do 'run_cmd_on_keyring' --fingerprint "$@"
	;;
    export|exportall)
	merge_all_trusted_keyrings_into_pubring
	aptkey_execute "$GPG_SH" --keyring "${GPGHOMEDIR}/pubring.gpg" --armor --export "$@"
	;;
    adv*)
	setup_merged_keyring
	aptkey_echo "Executing: $GPG $*"
	aptkey_execute "$GPG" "$@"
	merge_back_changes
	;;
    verify)
	GPGV=''
	eval $(apt-config shell GPGV Apt::Key::gpgvcommand)
	if [ -n "$GPGV" ] && which "$GPGV" >/dev/null 2>&1; then true;
	elif which gpgv >/dev/null 2>&1; then GPGV='gpgv';
	elif which gpgv2 >/dev/null 2>&1; then GPGV='gpgv2';
	else
	   echo >&2 'ERROR: gpgv or gpgv2 required for verification'
	   exit 29
	fi
	# for a forced keyid we need gpg --export, so full wrapping required
	if [ -n "$FORCED_KEYID" ]; then
	    prepare_gpg_home
	else
	    create_gpg_home
	fi
	setup_merged_keyring
	if [ -n "$FORCED_KEYRING" ]; then
	    "$GPGV" --homedir "${GPGHOMEDIR}" --keyring "${FORCED_KEYRING}" --ignore-time-conflict "$@"
	else
	    "$GPGV" --homedir "${GPGHOMEDIR}" --keyring "${GPGHOMEDIR}/pubring.gpg" --ignore-time-conflict "$@"
	fi
	;;
    help)
        usage
        ;;
    *)
        usage
        exit 1
        ;;
esac
