#!/bin/sh -- # no runable script, just for vi

EXIT_CODE=0

while [ -n "$1" ]; do
	if [ "$1" = "-q" ]; then
		export MSGLEVEL=2
	elif [ "$1" = "-v" ]; then
		export MSGLEVEL=4
	elif [ "$1" = '--color=no' ]; then
		export MSGCOLOR='NO'
	else
		echo >&2 "WARNING: Unknown parameter »$1« will be ignored"
	fi
	shift
done
export MSGLEVEL="${MSGLEVEL:-3}"

# we all like colorful messages
if [ "$MSGCOLOR" != 'NO' ] && [ "$MSGCOLOR" != 'ALWAYS' ]; then
	if [ ! -t 1 ]; then # but check that we output to a terminal
		export MSGCOLOR='NO'
	fi
fi


if [ "$MSGCOLOR" != 'NO' ]; then
	CERROR="\033[1;31m" # red
	CWARNING="\033[1;33m" # yellow
	CMSG="\033[1;32m" # green
	CINFO="\033[1;96m" # light blue
	CDEBUG="\033[1;94m" # blue
	CNORMAL="\033[0;39m" # default system console color
	CDONE="\033[1;32m" # green
	CPASS="\033[1;32m" # green
	CFAIL="\033[1;31m" # red
	CCMD="\033[1;35m" # pink
fi

msgprintf() {
	local START="$1"
	local MIDDLE="$2"
	local END="$3"
	shift 3
	if [ -n "$1" ]; then
		printf "$START " "$1"
		shift
		while [ -n "$1" ]; do
			printf "$MIDDLE " "$(echo "$1" | sed -e 's#^apt\([cfghs]\)#apt-\1#')"
			shift
		done
	fi
	printf "${END}"
}
msgdie() { msgprintf "${CERROR}E: %s" '%s' "${CNORMAL}\n" "$@" >&2; exit 1; }
msgwarn() { msgprintf "${CWARNING}W: %s" '%s' "${CNORMAL}\n" "$@" >&2; }
msgmsg() { msgprintf "${CMSG}%s" '%s' "${CNORMAL}\n" "$@"; }
msginfo() { msgprintf "${CINFO}I: %s" '%s' "${CNORMAL}\n" "$@"; }
msgdebug() { msgprintf "${CDEBUG}D: %s" '%s' "${CNORMAL}\n" "$@"; }
msgdone() { msgprintf "${CDONE}DONE" '%s' "${CNORMAL}\n" "$@"; }
msgnwarn() { msgprintf "${CWARNING}W: %s" '%s' "${CNORMAL}" "$@" >&2; }
msgnmsg() { msgprintf "${CMSG}%s" '%s' "${CNORMAL}" "$@"; }
msgninfo() { msgprintf "${CINFO}I: %s" '%s' "${CNORMAL}" "$@"; }
msgndebug() { msgprintf "${CDEBUG}D: %s" '%s' "${CNORMAL}" "$@"; }
msgtest() { msgprintf "${CINFO}%s" "${CCMD}%s${CINFO}" "…${CNORMAL} " "$@"; }
msgpass() { printf "${CPASS}PASS${CNORMAL}\n"; }
msgreportheader() {
	if [ -n "$MSGTEST_MSG" ]; then
		test "$1" != 'msgfailoutput' || echo
		if [ -n "$MSGTEST_MSGMSG" ]; then
			echo "$MSGTEST_MSGMSG"
		fi
		if [ -n "$MSGTEST_GRP" ] && [ "$MSGTEST_GRP" != 'NEXT' ] && [ "$MSGTEST_GRP" != "$MSGTEST_MSG" ]; then
			echo "${CFAIL}Part of the test group: $MSGTEST_GRP"
		fi
		echo -n "$MSGTEST_MSG"
		unset MSGTEST_MSG
	fi
}
msgskip() {
	msgreportheader 'msgskip'
	if [ $# -gt 0 ]; then printf "${CWARNING}SKIP: $*${CNORMAL}\n" >&2;
	else printf "${CWARNING}SKIP${CNORMAL}\n" >&2; fi
}
msgfail() {
	msgreportheader 'msgfail'
	if [ $# -gt 0 ] && [ -n "$1" ]; then printf "${CFAIL}FAIL: $*${CNORMAL}\n" >&2;
	else printf "${CFAIL}FAIL${CNORMAL}\n" >&2; fi
	if [ -n "$APT_DEBUG_TESTS" ]; then
		$SHELL
	fi
	EXIT_CODE=$((EXIT_CODE+1));
}
MSGGROUP_LEVEL=0
msggroup() {
	if [ -n "$1" ]; then
		if [ $MSGGROUP_LEVEL = 0 ]; then
			MSGTEST_GRP='NEXT'
		fi
		MSGGROUP_LEVEL=$((MSGGROUP_LEVEL+1));
	else
		MSGGROUP_LEVEL=$((MSGGROUP_LEVEL-1));
		if [ $MSGGROUP_LEVEL = 0 ]; then
			unset MSGTEST_GRP
		fi
	fi
}

# enable / disable Debugging
if [ $MSGLEVEL -le 0 ]; then
	msgdie() { true; }
fi
if [ $MSGLEVEL -le 1 ]; then
	msgwarn() { true; }
	msgnwarn() { true; }
fi
if [ $MSGLEVEL -le 2 ]; then
	msgmsg() {
		MSGTEST_MSGMSG="$(msgprintf "${CMSG}%s" '%s' "${CNORMAL}" "$@")"
	}
	msgnmsg() { true; }
	msgtest() {
		MSGTEST_MSG="$(msgprintf "${CINFO}%s" "${CCMD}%s${CINFO}" "…${CNORMAL} " "$@")"
		if [ "$MSGTEST_GRP" = 'NEXT' ]; then
			MSGTEST_GRP="$MSGTEST_MSG"
		fi
	}
	msgpass() { printf " ${CPASS}P${CNORMAL}"; }
fi
if [ $MSGLEVEL -le 3 ]; then
	msginfo() { true; }
	msgninfo() { true; }
fi
if [ $MSGLEVEL -le 4 ]; then
	msgdebug() { true; }
	msgndebug() { true; }
fi
msgdone() {
	if [ "$1" = "debug" -a $MSGLEVEL -le 4 ] ||
	   [ "$1" = "info" -a $MSGLEVEL -le 3 ] ||
	   [ "$1" = "msg" -a $MSGLEVEL -le 2 ] ||
	   [ "$1" = "warn" -a $MSGLEVEL -le 1 ] ||
	   [ "$1" = "die" -a $MSGLEVEL -le 0 ]; then
		true;
	else
		printf "${CDONE}DONE${CNORMAL}\n";
	fi
}
getaptconfig() {
	if [ -f ./aptconfig.conf ]; then
		echo "$(readlink -f ./aptconfig.conf)"
	elif [ -f ../aptconfig.conf ]; then
		echo "$(readlink -f ../aptconfig.conf)"
	elif [ -f ../../aptconfig.conf ]; then
		echo "$(readlink -f ../../aptconfig.conf)"
	elif [ -f "${TMPWORKINGDIRECTORY}/aptconfig.conf" ]; then
		echo "$(readlink -f "${TMPWORKINGDIRECTORY}/aptconfig.conf")"
	fi
}
runapt() {
	msgdebug "Executing: ${CCMD}$*${CDEBUG} "
	local CMD="$1"
	shift
	case $CMD in
	sh|aptitude|*/*|command) ;;
	*) CMD="${BUILDDIRECTORY}/$CMD";;
	esac
	MALLOC_PERTURB_=21 MALLOC_CHECK_=2 APT_CONFIG="$(getaptconfig)" LD_LIBRARY_PATH=${LIBRARYPATH} $CMD "$@"
}
aptconfig() { runapt apt-config "$@"; }
aptcache() { runapt apt-cache "$@"; }
aptcdrom() { runapt apt-cdrom "$@"; }
aptget() { runapt apt-get "$@"; }
aptftparchive() { runapt apt-ftparchive "$@"; }
aptkey() { runapt apt-key "$@"; }
aptmark() { runapt apt-mark "$@"; }
aptsortpkgs() { runapt apt-sortpkgs "$@"; }
apt() { runapt apt "$@"; }
apthelper() { runapt "${APTHELPERBINDIR}/apt-helper" "$@"; }
aptwebserver() { runapt "${APTWEBSERVERBINDIR}/aptwebserver" "$@"; }
aptitude() { runapt aptitude "$@"; }
aptextracttemplates() { runapt apt-extracttemplates "$@"; }
aptinternalsolver() { runapt "${APTINTERNALSOLVER}" "$@"; }
aptdumpsolver() { runapt "${APTDUMPSOLVER}" "$@"; }

dpkg() {
	"${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg" "$@"
}
dpkgcheckbuilddeps() {
	command dpkg-checkbuilddeps --admindir="${TMPWORKINGDIRECTORY}/rootdir/var/lib/dpkg" "$@"
}
gdb() {
	local CMD
	case "$1" in
	aptget) CMD="apt-get";;
	aptcache) CMD="apt-cache";;
	aptcdrom) CMD="apt-cdrom";;
	aptconfig) CMD="apt-config";;
	aptmark) CMD="apt-mark";;
	apthelper) CMD="apt-helper";;
	aptftparchive) CMD="apt-ftparchive";;
	dpkg) shift; runapt "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/gdb-dpkg" "$@"; return;;
	*) CMD="$1";;
	esac
	shift
	if [ "${CMD##*/}" = "$CMD" ]; then
		CMD="${BUILDDIRECTORY}/${CMD}"
	fi
	runapt command gdb --quiet -ex run "$CMD" --args "$CMD" "$@"
}

exitwithstatus() {
        # error if we about to overflow, but ...
        #   "255 failures ought to be enough for everybody"
        if [ $EXIT_CODE -gt 255 ]; then
            msgdie "Total failure count $EXIT_CODE too big"
        fi
        exit $((EXIT_CODE <= 255 ? EXIT_CODE : 255));
}

shellsetedetector() {
	local exit_status=$?
	if [ "$exit_status" != '0' ]; then
		printf >&2 "${CERROR}E: Looks like the testcases ended prematurely with exitcode: ${exit_status}${CNORMAL}\n"
		if [ "$EXIT_CODE" = '0' ]; then
			EXIT_CODE="$exit_status"
		fi
	fi
}

addtrap() {
	if [ "$1" = 'prefix' ]; then
		CURRENTTRAP="$2 $CURRENTTRAP"
	else
		CURRENTTRAP="$CURRENTTRAP $1"
	fi
	trap "shellsetedetector; $CURRENTTRAP exitwithstatus;" 0 HUP INT QUIT ILL ABRT FPE SEGV PIPE TERM
}

setupenvironment() {
	# privilege dropping and testing doesn't work if /tmp isn't world-writeable (as e.g. with libpam-tmpdir)
	if [ -n "$TMPDIR" ] && [ "$(id -u)" = '0' ] && [ "$(stat --format '%a' "$TMPDIR")" != '1777' ]; then
		unset TMPDIR
	fi
	TMPWORKINGDIRECTORY="$(mktemp -d)"
	addtrap "cd /; rm -rf \"$TMPWORKINGDIRECTORY\";"
	msgninfo "Preparing environment for ${0##*/} in ${TMPWORKINGDIRECTORY}…"

	mkdir -m 700 "${TMPWORKINGDIRECTORY}/downloaded"
	if [ "$(id -u)" = '0' ]; then
		# relax permissions so that running as root with user switching works
		umask 022
		chmod 711 "$TMPWORKINGDIRECTORY"
		chown _apt:root "${TMPWORKINGDIRECTORY}/downloaded"
	fi

	TESTDIRECTORY="$(readlink -f "$(dirname $0)")"
        # allow overriding the default BUILDDIR location
	SOURCEDIRECTORY="${APT_INTEGRATION_TESTS_SOURCE_DIR:-"${TESTDIRECTORY}/../../"}"
	BUILDDIRECTORY="${APT_INTEGRATION_TESTS_BUILD_DIR:-"${TESTDIRECTORY}/../../build/bin"}"
	LIBRARYPATH="${APT_INTEGRATION_TESTS_LIBRARY_PATH:-"${BUILDDIRECTORY}"}"
        METHODSDIR="${APT_INTEGRATION_TESTS_METHODS_DIR:-"${BUILDDIRECTORY}/methods"}"
        APTHELPERBINDIR="${APT_INTEGRATION_TESTS_LIBEXEC_DIR:-"${BUILDDIRECTORY}"}"
        APTWEBSERVERBINDIR="${APT_INTEGRATION_TESTS_WEBSERVER_BIN_DIR:-"${BUILDDIRECTORY}"}"
        APTINTERNALSOLVER="${APT_INTEGRATION_TESTS_INTERNAL_SOLVER:-"${BUILDDIRECTORY}/apt-internal-solver"}"
	APTDUMPSOLVER="${APT_INTEGRATION_TESTS_DUMP_SOLVER:-"${BUILDDIRECTORY}/apt-dump-solver"}"
	test -x "${BUILDDIRECTORY}/apt-get" || msgdie "You need to build tree first"
        # -----

	cd "$TMPWORKINGDIRECTORY"
	mkdir rootdir aptarchive keys
	cd rootdir
	mkdir -p etc/apt/apt.conf.d etc/apt/sources.list.d etc/apt/trusted.gpg.d etc/apt/preferences.d
	mkdir -p usr/bin var/cache var/lib var/log tmp
	mkdir -p var/lib/dpkg/info var/lib/dpkg/updates var/lib/dpkg/triggers
	touch var/lib/dpkg/available
	mkdir -p usr/lib/apt
	ln -s "${METHODSDIR}" usr/lib/apt/methods
	if [ "$BUILDDIRECTORY" = "$LIBRARYPATH" ]; then
		mkdir -p usr/lib/apt/solvers
		ln -s "${BUILDDIRECTORY}/apt-dump-solver" usr/lib/apt/solvers/dump
		ln -s "${BUILDDIRECTORY}/apt-internal-solver" usr/lib/apt/solvers/apt
		echo "Dir::Bin::Solvers \"${TMPWORKINGDIRECTORY}/rootdir/usr/lib/apt/solvers\";" > etc/apt/apt.conf.d/externalsolver.conf
	fi
        # use the autoremove from the BUILDDIRECTORY if its there, otherwise
        # system
        if [ -e "${BUILDDIRECTORY}/../../debian/apt.conf.autoremove" ]; then
	    ln -s "${BUILDDIRECTORY}/../../debian/apt.conf.autoremove" etc/apt/apt.conf.d/01autoremove
        else
	    ln -s /etc/apt/apt.conf.d/01autoremove etc/apt/apt.conf.d/01autoremove
        fi
	cd ..
	local BASENAME="${0##*/}"
	local PACKAGESFILE="Packages-${BASENAME#*-}"
	if [ -f "${TESTDIRECTORY}/${PACKAGESFILE}" ]; then
		cp "${TESTDIRECTORY}/${PACKAGESFILE}" aptarchive/Packages
	fi
	local SOURCESSFILE="Sources-${BASENAME#*-}"
	if [ -f "${TESTDIRECTORY}/${SOURCESSFILE}" ]; then
		cp "${TESTDIRECTORY}/${SOURCESSFILE}" aptarchive/Sources
	fi
	for key in $(find "$TESTDIRECTORY" -name '*.pub' -o -name '*.sec'); do
		cp "$key" keys/
		chmod 644 "$key"
	done
	ln -s "${TMPWORKINGDIRECTORY}/keys/joesixpack.pub" rootdir/etc/apt/trusted.gpg.d/joesixpack.gpg

	echo "Dir \"${TMPWORKINGDIRECTORY}/rootdir\";" > aptconfig.conf
	echo "Dir::state::status \"${TMPWORKINGDIRECTORY}/rootdir/var/lib/dpkg/status\";" >> aptconfig.conf
	echo "APT::Get::Show-User-Simulation-Note \"false\";" >> aptconfig.conf
	echo "Dir::Bin::Methods \"${TMPWORKINGDIRECTORY}/rootdir/usr/lib/apt/methods\";" >> aptconfig.conf
	# store apt-key were we can access it, even if we run it as a different user
	# destroys coverage reporting though, so just do it for root for now
	if [ "$(id -u)" = '0' ]; then
		cp "${BUILDDIRECTORY}/apt-key" "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/"
		chmod o+rx "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/apt-key"
		echo "Dir::Bin::apt-key \"${TMPWORKINGDIRECTORY}/rootdir/usr/bin/apt-key\";" >> aptconfig.conf
	else
		echo "Dir::Bin::apt-key \"${BUILDDIRECTORY}/apt-key\";" >> aptconfig.conf
	fi

	cat > "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg" <<EOF
#!/bin/sh
set -e
if [ -r "${TMPWORKINGDIRECTORY}/noopchroot.so" ]; then
	if [ -n "\$LD_LIBRARY_PATH" ]; then
		export LD_LIBRARY_PATH="${TMPWORKINGDIRECTORY}:${LD_LIBRARY_PATH}"
	else
		export LD_LIBRARY_PATH="${TMPWORKINGDIRECTORY}"
	fi
	if [ -n "\$LD_PRELOAD" ]; then
		export LD_PRELOAD="noopchroot.so \${LD_PRELOAD}"
	else
		export LD_PRELOAD="noopchroot.so"
	fi
fi
EOF
	cp "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg" "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/gdb-dpkg"
	cat >> "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg" <<EOF
exec fakeroot "${DPKG:-dpkg}" --root="${TMPWORKINGDIRECTORY}/rootdir" \\
	--log="${TMPWORKINGDIRECTORY}/rootdir/var/log/dpkg.log" \\
	--force-not-root --force-bad-path "\$@"
EOF
	cat >> "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/gdb-dpkg" <<EOF
exec fakeroot gdb --quiet -ex run "${DPKG:-dpkg}" --args "${DPKG:-dpkg}" --root="${TMPWORKINGDIRECTORY}/rootdir" \\
	--log="${TMPWORKINGDIRECTORY}/rootdir/var/log/dpkg.log" \\
	--force-not-root --force-bad-path "\$@"
EOF
	chmod +x "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg" "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/gdb-dpkg"
	echo "Dir::Bin::dpkg \"${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg\";" > rootdir/etc/apt/apt.conf.d/99dpkg

	{
		if ! command dpkg --assert-multi-arch >/dev/null 2>&1; then
			echo "DPKG::options:: \"--force-architecture\";" # Added to test multiarch before dpkg is ready for it…
		fi
		echo 'quiet::NoUpdate "true";'
		echo 'quiet::NoStatistic "true";'
		# too distracting for users, but helpful to detect changes
		echo 'Acquire::Progress::Ignore::ShowErrorText "true";'
		echo 'Acquire::Progress::Diffpercent "true";'
		# in testcases, it can appear as if localhost has a rotation setup,
		# hide this as we can't really deal with it properly
		echo 'Acquire::Failure::ShowIP "false";'
	} >> aptconfig.conf

	cp "${TESTDIRECTORY}/apt.pem" "${TMPWORKINGDIRECTORY}/rootdir/etc/webserver.pem"
	if [ "$(id -u)" = '0' ]; then
		chown _apt:root "${TMPWORKINGDIRECTORY}/rootdir/etc/webserver.pem"
	fi
	echo "Acquire::https::CaInfo \"${TMPWORKINGDIRECTORY}/rootdir/etc/webserver.pem\";" > rootdir/etc/apt/apt.conf.d/99https
	echo "Apt::Cmd::Disable-Script-Warning \"1\";" > rootdir/etc/apt/apt.conf.d/apt-binary
	configcompression '.' 'gz' #'bz2' 'lzma' 'xz'
	confighashes 'SHA1' # these are tests, not security best-practices

	# create some files in /tmp and look at user/group to get what this means
	TEST_DEFAULT_USER="$USER"
	if [ "$(uname)" = 'GNU/kFreeBSD' ]; then
		TEST_DEFAULT_GROUP='root'
	else
		TEST_DEFAULT_GROUP="$USER"
	fi

        # Acquire::AllowInsecureRepositories=false is not yet the default
        # but we want it to be the default soon
        configallowinsecurerepositories "false";

	# cleanup the environment a bit
        # prefer our apt binaries over the system apt binaries
	export PATH="${BUILDDIRECTORY}:${PATH}:/usr/local/sbin:/usr/sbin:/sbin"
	export LC_ALL=C.UTF-8
	unset LANGUAGE APT_CONFIG
	unset GREP_OPTIONS DEB_BUILD_PROFILES
	msgdone "info"
}

getarchitecture() {
	if [ "$1" = "native" -o -z "$1" ]; then
		eval `aptconfig shell ARCH APT::Architecture`
		if [ -n "$ARCH" ]; then
			echo $ARCH
		else
			dpkg --print-architecture
		fi
	else
		echo $1
	fi
}

getarchitectures() {
	aptconfig dump --no-empty --format '%v%n' APT::Architecture APT::Architectures | sort -u | tr '\n' ' '
}

getarchitecturesfromcommalist() {
	echo "$1" | sed -e 's#,#\n#g' | sed -e "s/^native\$/$(getarchitecture 'native')/"
}

configarchitecture() {
	{
		echo "APT::Architecture \"$(getarchitecture $1)\";"
		while [ -n "$1" ]; do
			echo "APT::Architectures:: \"$(getarchitecture $1)\";"
			shift
		done
	} >rootdir/etc/apt/apt.conf.d/01multiarch.conf
	configdpkg
}

configdpkg() {
	if [ ! -e rootdir/var/lib/dpkg/status ]; then
		local BASENAME="${0##*/}"
		local STATUSFILE="status-${BASENAME#*-}"
		if [ -f "${TESTDIRECTORY}/${STATUSFILE}" ]; then
			cp "${TESTDIRECTORY}/${STATUSFILE}" rootdir/var/lib/dpkg/status
		else
			echo -n > rootdir/var/lib/dpkg/status
		fi
	fi
	rm -f rootdir/etc/apt/apt.conf.d/00foreigndpkg
	if command dpkg --assert-multi-arch >/dev/null 2>&1 ; then
		local ARCHS="$(getarchitectures)"
		if echo "$ARCHS" | grep -E -q '[^ ]+ [^ ]+'; then
			DPKGARCH="$(dpkg --print-architecture)"
			for ARCH in ${ARCHS}; do
				if [ "${ARCH}" != "${DPKGARCH}" ]; then
					if ! dpkg --add-architecture ${ARCH} >/dev/null 2>&1; then
						# old-style used e.g. in Ubuntu-P – and as it seems travis
						echo "DPKG::options:: \"--foreign-architecture\";" >> rootdir/etc/apt/apt.conf.d/00foreigndpkg
						echo "DPKG::options:: \"${ARCH}\";"  >> rootdir/etc/apt/apt.conf.d/00foreigndpkg
					fi
				fi
			done
			if [ "0" = "$(dpkg -l dpkg 2> /dev/null | grep '^i' | wc -l)" ]; then
				# dpkg doesn't really check the version as long as it is fully installed,
				# but just to be sure we choose one above the required version
				insertinstalledpackage 'dpkg' "all" '1.16.2+fake'
			fi
		fi
	fi
}

configdpkgnoopchroot() {
	# create a library to noop chroot() and rewrite maintainer script executions
	# via execvp() as used by dpkg as we don't want our rootdir to be a fullblown
	# chroot directory dpkg could chroot into to execute the maintainer scripts
	msgtest 'Building library to preload to make maintainerscript work in' 'dpkg'
	cat > noopchroot.c << EOF
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>

static char * chrootdir = NULL;

int chroot(const char *path) {
	printf("WARNING: CHROOTing to %s was ignored!\n", path);
	free(chrootdir);
	chrootdir = strdup(path);
	return 0;
}
int execvp(const char *file, char *const argv[]) {
	static int (*func_execvp) (const char *, char * const []) = NULL;
	if (func_execvp == NULL)
		func_execvp = (int (*) (const char *, char * const [])) dlsym(RTLD_NEXT, "execvp");
	if (chrootdir == NULL || strncmp(file, "/var/lib/dpkg/", strlen("/var/lib/dpkg/")) != 0)
		return func_execvp(file, argv);
	printf("REWRITE execvp call %s into %s\n", file, chrootdir);
	char newfile[strlen(chrootdir) + strlen(file)];
	strcpy(newfile, chrootdir);
	strcat(newfile, file);
	char const * const baseadmindir = "/var/lib/dpkg";
	char admindir[strlen(chrootdir) + strlen(baseadmindir)];
	strcpy(admindir, chrootdir);
	strcat(admindir, baseadmindir);
	setenv("DPKG_ADMINDIR", admindir, 1);
	return func_execvp(newfile, argv);
}
EOF
	testsuccess --nomsg gcc -fPIC -shared -o noopchroot.so noopchroot.c -ldl
}

configallowinsecurerepositories() {
    echo "Acquire::AllowInsecureRepositories \"$1\";" >  rootdir/etc/apt/apt.conf.d/allow-insecure-repositories.conf

}

configcompression() {
	while [ -n "$1" ]; do
		case "$1" in
		'.') printf ".\t.\tcat\n";;
		'gz') printf "gzip\tgz\tgzip\n";;
		'bz2') printf "bzip2\tbz2\tbzip2\n";;
		'lzma') printf "lzma\tlzma\txz --format=lzma\n";;
		'xz') printf "xz\txz\txz\n";;
		*) printf "$1\t$1\t$1\n";;
		esac
		shift
	done > "${TMPWORKINGDIRECTORY}/rootdir/etc/testcase-compressor.conf"
}
confighashes() {
	{
		echo 'APT::FTPArchive {'
		{
			while [ -n "$1" ]; do
				printf "$1" | tr 'a-z' 'A-Z'
				printf "\t\"true\";\n"
				shift
			done
			for h in 'MD5' 'SHA1' 'SHA256' 'SHA512'; do
				printf "$h\t\"false\";\n"
			done
		} | awk '!x[$1]++'
		echo '};'
	} >> "${TMPWORKINGDIRECTORY}/rootdir/etc/apt/apt.conf.d/ftparchive-hashes.conf"
}
forcecompressor() {
	COMPRESSOR="$1"
	COMPRESSOR_CMD="$1"
	case $COMPRESSOR in
	gzip) COMPRESS='gz';;
	bzip2) COMPRESS='bz2';;
	lzma) COMPRESS='lzma';;
	xz) COMPRESS='xz';;
	*) msgdie "Compressor $COMPRESSOR is unknown to framework, so can't be forced by forcecompressor!";;
	esac
	local CONFFILE="${TMPWORKINGDIRECTORY}/rootdir/etc/apt/apt.conf.d/00force-compressor"
	echo "Acquire::CompressionTypes::Order { \"${COMPRESS}\"; };
Dir::Bin::uncompressed \"/does/not/exist\";
Dir::Bin::gzip \"/does/not/exist\";
Dir::Bin::bzip2 \"/does/not/exist\";
Dir::Bin::lzma \"/does/not/exist\";
Dir::Bin::xz \"/does/not/exist\";" > "$CONFFILE"
	if [ -e "/bin/${COMPRESSOR}" ]; then
		echo "Dir::Bin::${COMPRESSOR} \"/bin/${COMPRESSOR}\";" >> "$CONFFILE"
	elif [ -e "/usr/bin/${COMPRESSOR}" ]; then
		echo "Dir::Bin::${COMPRESSOR} \"/usr/bin/${COMPRESSOR}\";" >> "$CONFFILE"
	elif [ "${COMPRESSOR}" = 'lzma' ]; then
		echo 'Dir::Bin::xz "/usr/bin/xz";' >> "$CONFFILE"
		COMPRESSOR_CMD='xz --format=lzma'
	else
		msgtest 'Test for availability of compressor' "${COMPRESSOR}"
		msgfail "${COMPRESSOR} not available"
	fi
}

setupsimplenativepackage() {
	local NAME="$1"
	local ARCH="$2"
	local VERSION="$3"
	local RELEASE="${4:-unstable}"
	local DEPENDENCIES="$5"
	local DESCRIPTION="${6:-"an autogenerated dummy ${NAME}=${VERSION}/${RELEASE}
 If you find such a package installed on your system,
 something went horribly wrong! They are autogenerated
 und used only by testcases and surf no other propose…"}"

	local SECTION="${7:-others}"
	local DISTSECTION
	if [ "$SECTION" = "${SECTION#*/}" ]; then
		DISTSECTION="main"
	else
		DISTSECTION="${SECTION%/*}"
	fi
	local BUILDDIR=incoming/${NAME}-${VERSION}
	mkdir -p ${BUILDDIR}/debian/source
	cd ${BUILDDIR}
	echo "* most suckless software product ever" > FEATURES
	test -e debian/copyright || echo "Copyleft by Joe Sixpack $(date +%Y)" > debian/copyright
	test -e debian/changelog || echo "$NAME ($VERSION) $RELEASE; urgency=low

  * Initial release

 -- Joe Sixpack <joe@example.org>  $(date -R)" > debian/changelog
	test -e debian/control || echo "Source: $NAME
Section: $SECTION
Priority: optional
Maintainer: Joe Sixpack <joe@example.org>
Build-Depends: debhelper (>= 7)
Standards-Version: 3.9.1

Package: $NAME" > debian/control
	if [ "$ARCH" = 'all' ]; then
		echo "Architecture: all" >> debian/control
	else
		echo "Architecture: any" >> debian/control
	fi
	test -z "$DEPENDENCIES" || echo "$DEPENDENCIES" >> debian/control
	echo "Description: $DESCRIPTION" >> debian/control

	test -e debian/compat || echo "7" > debian/compat
	test -e debian/source/format || echo "3.0 (native)" > debian/source/format
	test -e debian/rules || cp /usr/share/doc/debhelper/examples/rules.tiny debian/rules
	cd - > /dev/null
}

buildsimplenativepackage() {
	local NAME="$1"
	local NM
	if [ "$(echo "$NAME" | cut -c 1-3)" = 'lib' ]; then
		NM="$(echo "$NAME" | cut -c 1-4)"
	else
		NM="$(echo "$NAME" | cut -c 1)"
	fi
	local ARCH="$2"
	local VERSION="$3"
	local RELEASE="${4:-unstable}"
	local DEPENDENCIES="$5"
	local DESCRIPTION="${6:-"an autogenerated dummy ${NAME}=${VERSION}/${RELEASE}
 If you find such a package installed on your system,
 something went horribly wrong! They are autogenerated
 und used only by testcases and surf no other propose…"}"

	local SECTION="${7:-others}"
	local PRIORITY="${8:-optional}"
	local FILE_TREE="$9"
	local COMPRESS_TYPE="${10:-gzip}"
	local DISTSECTION
	if [ "$SECTION" = "${SECTION#*/}" ]; then
		DISTSECTION="main"
	else
		DISTSECTION="${SECTION%/*}"
	fi
	local BUILDDIR="${TMPWORKINGDIRECTORY}/incoming/${NAME}-${VERSION}"

	msgtest "Build source package in version ${VERSION} for ${RELEASE} in ${DISTSECTION}" "$NAME"
	mkdir -p "$BUILDDIR/debian/source"
	echo "* most suckless software product ever" > "${BUILDDIR}/FEATURES"
	echo "#!/bin/sh
echo '$NAME says \"Hello!\"'" > "${BUILDDIR}/${NAME}"

	echo "Copyleft by Joe Sixpack $(date +%Y)" > "${BUILDDIR}/debian/copyright"
	echo "$NAME ($VERSION) $RELEASE; urgency=low

  * Initial release

 -- Joe Sixpack <joe@example.org>  $(date -R)" > "${BUILDDIR}/debian/changelog"
	{
		echo "Source: $NAME
Priority: $PRIORITY
Maintainer: Joe Sixpack <joe@example.org>
Standards-Version: 3.9.3"
		if [ "$SECTION" != '<none>' ]; then
			echo "Section: $SECTION"
		fi
		local BUILDDEPS="$(echo "$DEPENDENCIES" | grep '^Build-')"
		test -z "$BUILDDEPS" || echo "$BUILDDEPS"
		echo "
Package: $NAME"

		if [ "$ARCH" = 'all' ]; then
			echo "Architecture: all"
		else
			echo "Architecture: any"
		fi
		local DEPS="$(echo "$DEPENDENCIES" | grep -v '^Build-')"
		test -z "$DEPS" || echo "$DEPS"
		echo "Description: $DESCRIPTION"
	} > "${BUILDDIR}/debian/control"

	echo '3.0 (native)' > "${BUILDDIR}/debian/source/format"
	cd "${BUILDDIR}/.."
	testsuccess --nomsg dpkg-source -b ${NAME}-${VERSION}
	cd - >/dev/null
	sed -n 's#^dpkg-source: info: building [^ ]\+ in ##p' "${TMPWORKINGDIRECTORY}/rootdir/tmp/testsuccess.output" \
		| while read SRC; do
		echo "pool/${SRC}" >> "${BUILDDIR}/../${RELEASE}.${DISTSECTION}.srclist"
#		if expr match "${SRC}" '.*\.dsc' >/dev/null 2>&1; then
#			aptkey --keyring ./keys/joesixpack.pub --secret-keyring ./keys/joesixpack.sec --quiet --readonly \
#				adv --yes --default-key 'Joe Sixpack' \
#				--clearsign -o "${BUILDDIR}/../${SRC}.sign" "${BUILDDIR}/../$SRC"
#			mv "${BUILDDIR}/../${SRC}.sign" "${BUILDDIR}/../$SRC"
#		fi
	done

	for arch in $(getarchitecturesfromcommalist "$ARCH"); do
		msgtest "Build binary package for ${RELEASE} in ${SECTION}" "$NAME"
		rm -rf "${BUILDDIR}/debian/tmp"
		mkdir -p "${BUILDDIR}/debian/tmp/DEBIAN" "${BUILDDIR}/debian/tmp/usr/share/doc/${NAME}" "${BUILDDIR}/debian/tmp/usr/bin"
		cp "${BUILDDIR}/debian/copyright" "${BUILDDIR}/debian/changelog" "${BUILDDIR}/FEATURES" "${BUILDDIR}/debian/tmp/usr/share/doc/${NAME}"
		cp "${BUILDDIR}/${NAME}" "${BUILDDIR}/debian/tmp/usr/bin/${NAME}-${arch}"
                if [ -n "$FILE_TREE" ]; then
                    cp -ar "$FILE_TREE" "${BUILDDIR}/debian/tmp"
                fi

		(cd "${BUILDDIR}"; dpkg-gencontrol -DArchitecture=$arch)
		(cd "${BUILDDIR}/debian/tmp"; md5sum $(find usr/ -type f) > DEBIAN/md5sums)
		local LOG="${BUILDDIR}/../${NAME}_${VERSION}_${arch}.dpkg-deb.log"
		# ensure the right permissions as dpkg-deb insists
		chmod 755 "${BUILDDIR}/debian/tmp/DEBIAN"
		testsuccess --nomsg dpkg-deb -Z${COMPRESS_TYPE} --build "${BUILDDIR}/debian/tmp" "${BUILDDIR}/.."
		echo "pool/${NAME}_${VERSION}_${arch}.deb" >> "${BUILDDIR}/../${RELEASE}.${DISTSECTION}.pkglist"
	done

	local CHANGEPATH="${BUILDDIR}/../${DISTSECTION}/${NM}/${NAME}/${NAME}_${VERSION}"
	mkdir -p "$CHANGEPATH"
	cp "${BUILDDIR}/debian/changelog" "$CHANGEPATH"
	rm -rf "${BUILDDIR}"
	msgdone "info"
}

buildpackage() {
	local BUILDDIR=$1
	local RELEASE=$2
	local SECTION=$3
	local ARCH=$(getarchitecture $4)
	local PKGNAME="$(echo "$BUILDDIR" | grep -o '[^/]*$')"
	local BUILDLOG="$(readlink -f "${BUILDDIR}/../${PKGNAME}_${RELEASE}_${SECTION}.dpkg-bp.log")"
	msgtest "Build package for ${RELEASE} in ${SECTION}" "$PKGNAME"
	cd "$BUILDDIR"
	if [ "$ARCH" = "all" ]; then
		ARCH="$(dpkg-architecture -qDEB_HOST_ARCH 2> /dev/null)"
	fi
	testsuccess --nomsg dpkg-buildpackage -uc -us -a$ARCH
	cp "${TMPWORKINGDIRECTORY}/rootdir/tmp/testsuccess.output" "$BUILDLOG"
	local PKGS="$(grep '^dpkg-deb: building package' "$BUILDLOG" | cut -d'/' -f 2 | sed -e "s#'\.##")"
	local SRCS="$(grep '^dpkg-source: info: building' "$BUILDLOG" | grep -o '[a-z0-9._+~-]*$')"
	cd - > /dev/null
	for PKG in $PKGS; do
		echo "pool/${PKG}" >> "${TMPWORKINGDIRECTORY}/incoming/${RELEASE}.${SECTION}.pkglist"
	done
	for SRC in $SRCS; do
		echo "pool/${SRC}" >> "${TMPWORKINGDIRECTORY}/incoming/${RELEASE}.${SECTION}.srclist"
	done
}

buildaptarchive() {
	if [ -d incoming ]; then
		buildaptarchivefromincoming "$@"
	else
		buildaptarchivefromfiles "$@"
	fi
}

createaptftparchiveconfig() {
	local COMPRESSORS="$(cut -d'	' -f 1 "${TMPWORKINGDIRECTORY}/rootdir/etc/testcase-compressor.conf" | tr '\n' ' ')"
	local COMPRESSORS="${COMPRESSORS%* }"
	local ARCHS="$(getarchitectures)"
	cat > ftparchive.conf <<EOF
Dir {
	ArchiveDir "$(readlink -f .)";
	CacheDir "$(readlink -f ..)";
	FileListDir "$(readlink -f pool/)";
};
Default {
	Packages::Compress "$COMPRESSORS";
	Sources::Compress "$COMPRESSORS";
	Contents::Compress "$COMPRESSORS";
	Translation::Compress "$COMPRESSORS";
	LongDescription "false";
};
TreeDefault {
	Directory "pool/";
	SrcDirectory "pool/";
};
EOF
	for DIST in $(find ./pool/ -maxdepth 1 -name '*.pkglist' -type f | cut -d'/' -f 3 | cut -d'.' -f 1 | sort | uniq); do
		cat <<EOF
tree "dists/$DIST" {
	Architectures "$ARCHS source";
	FileList "${DIST}.\$(SECTION).pkglist";
	SourceFileList "${DIST}.\$(SECTION).srclist";
	Sections "$(find ./pool/ -maxdepth 1 -name "${DIST}.*.pkglist" -type f | cut -d'/' -f 3 | cut -d'.' -f 2 | sort | uniq | tr '\n' ' ')";
};
EOF
	done >> ftparchive.conf
}

buildaptftparchivedirectorystructure() {
	local DISTS="$(grep -i '^tree ' ftparchive.conf | cut -d'/' -f 2 | sed -e 's#".*##')"
	for DIST in $DISTS; do
		local SECTIONS="$(grep -i -A 5 "dists/$DIST" ftparchive.conf | grep -i 'Sections' | cut -d'"' -f 2)"
		for SECTION in $SECTIONS; do
			local ARCHS="$(grep -A 5 "dists/$DIST" ftparchive.conf | grep Architectures | cut -d'"' -f 2 | sed -e 's#source##')"
			for ARCH in $ARCHS; do
				mkdir -p "dists/${DIST}/${SECTION}/binary-${ARCH}"
			done
			mkdir -p "dists/${DIST}/${SECTION}/source"
			mkdir -p "dists/${DIST}/${SECTION}/i18n"
		done
	done
}

insertpackage() {
	local RELEASES="$1"
	local NAME="$2"
	local ARCH="$3"
	local VERSION="$4"
	local DEPENDENCIES="$5"
	local PRIORITY="${6:-optional}"
	local DESCRIPTION="${7:-"an autogenerated dummy ${NAME}=${VERSION}/${RELEASES}
 If you find such a package installed on your system,
 something went horribly wrong! They are autogenerated
 und used only by testcases and surf no other propose…"}"
	local ARCHS=""
	for RELEASE in $(printf '%s' "$RELEASES" | tr ',' '\n'); do
		if [ "$RELEASE" = 'installed' ]; then
			insertinstalledpackage "$2" "$3" "$4" "$5" "$6" "$7"
			continue
		fi
		for arch in $(getarchitecturesfromcommalist "$ARCH"); do
			if [ "$arch" = 'all' -o "$arch" = 'none' ]; then
				ARCHS="$(getarchitectures)"
			else
				ARCHS="$arch"
			fi
			for BUILDARCH in $ARCHS; do
				local PPATH="aptarchive/dists/${RELEASE}/main/binary-${BUILDARCH}"
				mkdir -p "$PPATH"
				{
					echo "Package: $NAME
Priority: $PRIORITY
Section: other
Installed-Size: 42
Maintainer: Joe Sixpack <joe@example.org>"
					test "$arch" = 'none' || echo "Architecture: $arch"
					echo "Version: $VERSION
Filename: pool/main/${NAME}/${NAME}_${VERSION}_${arch}.deb"
					test -z "$DEPENDENCIES" || echo "$DEPENDENCIES"
					echo "Description: $(printf '%s' "$DESCRIPTION" | head -n 1)"
					echo "Description-md5: $(printf '%s' "$DESCRIPTION" | md5sum | cut -d' ' -f 1)"
					echo
				} >> "${PPATH}/Packages"
			done
		done
		mkdir -p "aptarchive/dists/${RELEASE}/main/source" "aptarchive/dists/${RELEASE}/main/i18n"
		touch "aptarchive/dists/${RELEASE}/main/source/Sources"
		echo "Package: $NAME
Description-md5: $(printf '%s' "$DESCRIPTION" | md5sum | cut -d' ' -f 1)
Description-en: $DESCRIPTION
" >> "aptarchive/dists/${RELEASE}/main/i18n/Translation-en"
	done
}

insertsource() {
	local RELEASE="$1"
	local NAME="$2"
	local ARCH="$3"
	local VERSION="$4"
	local DEPENDENCIES="$5"
        local BINARY="${6:-$NAME}"
	local ARCHS=""
	local SPATH="aptarchive/dists/${RELEASE}/main/source"
	mkdir -p $SPATH
	local FILE="${SPATH}/Sources"
	local DSCFILE="${NAME}_${VERSION}.dsc"
	local TARFILE="${NAME}_${VERSION}.tar.gz"
	echo "Package: $NAME
Binary: $BINARY
Version: $VERSION
Maintainer: Joe Sixpack <joe@example.org>
Architecture: $ARCH" >> $FILE
	test -z "$DEPENDENCIES" || echo "$DEPENDENCIES" >> "$FILE"
	echo "Files:
 $(echo -n "$DSCFILE" | md5sum | cut -d' ' -f 1) $(echo -n "$DSCFILE" | wc -c) "$DSCFILE"
 $(echo -n "$TARFILE" | md5sum | cut -d' ' -f 1) $(echo -n "$TARFILE" | wc -c) "$TARFILE"
Checksums-Sha256:
 $(echo -n "$DSCFILE" | sha256sum | cut -d' ' -f 1) $(echo -n "$DSCFILE" | wc -c) "$DSCFILE"
 $(echo -n "$TARFILE" | sha256sum | cut -d' ' -f 1) $(echo -n "$TARFILE" | wc -c) "$TARFILE"
" >> "$FILE"
}

insertinstalledpackage() {
	local NAME="$1"
	local ARCH="$2"
	local VERSION="$3"
	local DEPENDENCIES="$4"
	local PRIORITY="${5:-optional}"
	local STATUS="${6:-install ok installed}"
	local DESCRIPTION="${7:-"an autogenerated dummy ${NAME}=${VERSION}/installed
 If you find such a package installed on your system,
 something went horribly wrong! They are autogenerated
 und used only by testcases and surf no other propose…"}"

	local FILE='rootdir/var/lib/dpkg/status'
	local INFO='rootdir/var/lib/dpkg/info'
	for arch in $(getarchitecturesfromcommalist "$ARCH"); do
		echo "Package: $NAME
Status: $STATUS
Priority: $PRIORITY
Section: other
Installed-Size: 42
Maintainer: Joe Sixpack <joe@example.org>
Version: $VERSION" >> "$FILE"
		test "$arch" = 'none' || echo "Architecture: $arch" >> "$FILE"
		test -z "$DEPENDENCIES" || echo "$DEPENDENCIES" >> "$FILE"
		echo "Description: $DESCRIPTION" >> "$FILE"
		echo >> "$FILE"
		if [ "$(dpkg-query -W --showformat='${Multi-Arch}')" = 'same' ]; then
			echo -n > "${INFO}/${NAME}:${arch}.list"
		else
			echo -n > "${INFO}/${NAME}.list"
		fi
	done
}


buildaptarchivefromincoming() {
	msginfo "Build APT archive for ${CCMD}${0##*/}${CINFO} based on incoming packages…"
	cd aptarchive
	[ -e pool ] || ln -s ../incoming pool
	[ -e ftparchive.conf ] || createaptftparchiveconfig
	[ -e dists ] || buildaptftparchivedirectorystructure
	msgninfo "\tGenerate Packages, Sources and Contents files… "
	testsuccess aptftparchive generate ftparchive.conf
	cd - > /dev/null
	msgdone "info"
	generatereleasefiles "$@"
}

buildaptarchivefromfiles() {
	msginfo "Build APT archive for ${CCMD}${0##*/}${CINFO} based on prebuild files…"
	local DIR='aptarchive'
	if [ -d "${DIR}/dists" ]; then DIR="${DIR}/dists"; fi
	find "$DIR" -name 'Packages' -o -name 'Sources' -o -name 'Translation-*' | while read line; do
		msgninfo "\t${line} file… "
		compressfile "$line" "$1"
		msgdone "info"
	done
	generatereleasefiles "$@"
}

compressfile() {
	cat "${TMPWORKINGDIRECTORY}/rootdir/etc/testcase-compressor.conf" | while read compressor extension command; do
		if [ "$compressor" = '.' ]; then
			if [ -n "$2" ]; then
				touch -d "$2" "$1"
			fi
			continue
		fi
		cat "$1" | $command > "${1}.${extension}"
		if [ -n "$2" ]; then
			touch -d "$2" "${1}.${extension}"
		fi
	done
}

# can be overridden by testcases for their pleasure
getcodenamefromsuite() {
	case "$1" in
	unstable) echo 'sid';;
	*) echo -n "$1";;
	esac
}
getreleaseversionfromsuite() { true; }
getlabelfromsuite() { true; }
getoriginfromsuite() { true; }

aptftparchiverelease() {
	aptftparchive -qq release "$@" | sed -e '/0 Release$/ d' # remove the self reference
}
generatereleasefiles() {
	# $1 is the Date header and $2 is the ValidUntil header to be set
	# both should be given in notation date/touch can understand
	msgninfo "\tGenerate Release files… "
	if [ -e aptarchive/dists ]; then
		for dir in $(find ./aptarchive/dists -mindepth 1 -maxdepth 1 -type d); do
			local SUITE="$(echo "$dir" | cut -d'/' -f 4)"
			local CODENAME="$(getcodenamefromsuite $SUITE)"
			local VERSION="$(getreleaseversionfromsuite $SUITE)"
			local LABEL="$(getlabelfromsuite $SUITE)"
			local ORIGIN="$(getoriginfromsuite $SUITE)"
			if [ -n "$VERSION" ]; then
				VERSION="-o APT::FTPArchive::Release::Version=${VERSION}"
			fi
			if [ -n "$LABEL" ]; then
				LABEL="-o APT::FTPArchive::Release::Label=${LABEL}"
			fi
			if [ -n "$ORIGIN" ]; then
				ORIGIN="-o APT::FTPArchive::Release::Origin=${ORIGIN}"
			fi
			aptftparchiverelease "$dir" \
				-o APT::FTPArchive::Release::Suite="${SUITE}" \
				-o APT::FTPArchive::Release::Codename="${CODENAME}" \
				${LABEL} \
				${ORIGIN} \
				${VERSION} \
				> "$dir/Release"
			if [ "$SUITE" = "experimental" -o "$SUITE" = "experimental2" ]; then
				sed -i '/^Date: / a\
NotAutomatic: yes' "$dir/Release"
			fi
		done
	else
		aptftparchiverelease ./aptarchive > aptarchive/Release
	fi
	if [ -n "$1" -a "$1" != "now" ]; then
		for release in $(find ./aptarchive -name 'Release'); do
			sed -i "s/^Date: .*$/Date: $(date -d "$1" '+%a, %d %b %Y %H:%M:%S %Z')/" "$release"
			touch -d "$1" "$release"
		done
	fi
	if [ -n "$2" ]; then
		sed -i "/^Date: / a\
Valid-Until: $(date -d "$2" '+%a, %d %b %Y %H:%M:%S %Z')" $(find ./aptarchive -name 'Release')
	fi
	msgdone "info"
}

setupdistsaptarchive() {
	local APTARCHIVE="$(readlink -f ./aptarchive | sed 's# #%20#g')"
	rm -f root/etc/apt/sources.list.d/apt-test-*-deb.list
	rm -f root/etc/apt/sources.list.d/apt-test-*-deb-src.list
	for DISTS in $(find ./aptarchive/dists/ -mindepth 1 -maxdepth 1 -type d | cut -d'/' -f 4); do
		SECTIONS=$(find "./aptarchive/dists/${DISTS}/" -mindepth 1 -maxdepth 1 -type d | cut -d'/' -f 5 | tr '\n' ' ')
		msgninfo "\tadd deb and deb-src sources.list lines for ${CCMD}${DISTS} ${SECTIONS}${CINFO}… "
		echo "deb file://$APTARCHIVE $DISTS $SECTIONS" > "rootdir/etc/apt/sources.list.d/apt-test-${DISTS}-deb.list"
		echo "deb-src file://$APTARCHIVE $DISTS $SECTIONS" > "rootdir/etc/apt/sources.list.d/apt-test-${DISTS}-deb-src.list"
		msgdone "info"
	done
}

setupflataptarchive() {
	local APTARCHIVE="$(readlink -f ./aptarchive)"
	local APTARCHIVEURI="$(readlink -f ./aptarchive | sed 's# #%20#g')"
	if [ -f "${APTARCHIVE}/Packages" ]; then
		msgninfo "\tadd deb sources.list line… "
		echo "deb file://$APTARCHIVEURI /" > 'rootdir/etc/apt/sources.list.d/apt-test-archive-deb.list'
		msgdone 'info'
	else
		rm -f 'rootdir/etc/apt/sources.list.d/apt-test-archive-deb.list'
	fi
	if [ -f "${APTARCHIVE}/Sources" ]; then
		msgninfo "\tadd deb-src sources.list line… "
		echo "deb-src file://$APTARCHIVEURI /" > 'rootdir/etc/apt/sources.list.d/apt-test-archive-deb-src.list'
		msgdone 'info'
	else
		rm -f 'rootdir/etc/apt/sources.list.d/apt-test-archive-deb-src.list'
	fi
}

setupaptarchive() {
	local NOUPDATE=0
	if [ "$1" = '--no-update' ]; then
		NOUPDATE=1
		shift
	fi
	buildaptarchive "$@"
	if [ -e aptarchive/dists ]; then
		setupdistsaptarchive
	else
		setupflataptarchive
	fi
	signreleasefiles 'Joe Sixpack'
	if [ "1" != "$NOUPDATE" ]; then
		testsuccess aptget update -o Debug::pkgAcquire::Worker=true -o Debug::Acquire::gpgv=true
	fi
}

signreleasefiles() {
	local SIGNER="${1:-Joe Sixpack}"
	local REPODIR="${2:-aptarchive}"
	local KEY="keys/$(echo "$SIGNER" | tr 'A-Z' 'a-z' | sed 's# ##g')"
	local GPG="aptkey --quiet --keyring ${KEY}.pub --secret-keyring ${KEY}.sec --readonly adv --batch --yes"
	msgninfo "\tSign archive with $SIGNER key $KEY… "
	local REXKEY='keys/rexexpired'
	local SECEXPIREBAK="${REXKEY}.sec.bak"
	local PUBEXPIREBAK="${REXKEY}.pub.bak"
	if [ "${SIGNER}" = 'Rex Expired' ]; then
		# the key is expired, so gpg doesn't allow to sign with and the --faked-system-time
		# option doesn't exist anymore (and using faketime would add a new obscure dependency)
		# therefore we 'temporary' make the key not expired and restore a backup after signing
		cp "${REXKEY}.sec" "$SECEXPIREBAK"
		cp "${REXKEY}.pub" "$PUBEXPIREBAK"
		local SECUNEXPIRED="${REXKEY}.sec.unexpired"
		local PUBUNEXPIRED="${REXKEY}.pub.unexpired"
		if [ -f "$SECUNEXPIRED" ] && [ -f "$PUBUNEXPIRED" ]; then
			cp "$SECUNEXPIRED" "${REXKEY}.sec"
			cp "$PUBUNEXPIRED" "${REXKEY}.pub"
		else
			if ! printf "expire\n1w\nsave\n" | $GPG --default-key "$SIGNER" --command-fd 0 --edit-key "${SIGNER}" >setexpire.gpg 2>&1; then
				cat setexpire.gpg
				exit 1
			fi
			cp "${REXKEY}.sec" "$SECUNEXPIRED"
			cp "${REXKEY}.pub" "$PUBUNEXPIRED"
		fi
	fi
	for RELEASE in $(find "${REPODIR}/" -name Release); do
		$GPG --default-key "$SIGNER" --armor --detach-sign --sign --output "${RELEASE}.gpg" "${RELEASE}"
		local INRELEASE="$(echo "${RELEASE}" | sed 's#/Release$#/InRelease#')"
		$GPG --default-key "$SIGNER" --clearsign --output "$INRELEASE" "$RELEASE"
		# we might have set a specific date for the Release file, so copy it
		touch -d "$(stat --format "%y" ${RELEASE})" "${RELEASE}.gpg" "${INRELEASE}"
	done
	if [ -f "$SECEXPIREBAK" ] && [ -f "$PUBEXPIREBAK" ]; then
		mv -f "$SECEXPIREBAK" "${REXKEY}.sec"
		mv -f "$PUBEXPIREBAK" "${REXKEY}.pub"
	fi
	msgdone 'info'
}

redatereleasefiles() {
	local DATE="$(date -d "$1" '+%a, %d %b %Y %H:%M:%S %Z')"
	for release in $(find aptarchive/ -name 'Release'); do
		sed -i "s/^Date: .*$/Date: ${DATE}/" "$release"
		touch -d "$DATE" "$release"
	done
	signreleasefiles "${2:-Joe Sixpack}"
}

webserverconfig() {
	local WEBSERVER="${3:-http://localhost:8080}"
	local NOCHECK=false
	if [ "$1" = '--no-check' ]; then
		NOCHECK=true
		shift
	fi
	local DOWNLOG='rootdir/tmp/download-testfile.log'
	local STATUS='downloaded/webserverconfig.status'
	rm -f "$STATUS" "$DOWNLOG"
	local URI
	if [ -n "$2" ]; then
		msgtest "Set webserver config option '${1}' to" "$2"
		URI="${WEBSERVER}/_config/set/${1}/${2}"
	else
		msgtest 'Clear webserver config option' "${1}"
		URI="${WEBSERVER}/_config/clear/${1}"
	fi
	if downloadfile "$URI" "$STATUS" > "$DOWNLOG"; then
		msgpass
	else
		local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/webserverconfig.output"
		cat "$DOWNLOG" "$STATUS" >"$OUTPUT" 2>&1 || true
		msgfailoutput '' "$OUTPUT"
	fi
	$NOCHECK || testwebserverlaststatuscode '200'
}

rewritesourceslist() {
	local APTARCHIVE="file://$(readlink -f "${TMPWORKINGDIRECTORY}/aptarchive" | sed 's# #%20#g')"
	for LIST in $(find rootdir/etc/apt/sources.list.d/ -name 'apt-test-*.list'); do
		sed -i $LIST -e "s#$APTARCHIVE#${1}#" -e "s#http://localhost:8080/#${1}#" -e "s#https://localhost:4433/#${1}#"
	done
}

# wait for up to 10s for a pid file to appear to avoid possible race
# when a helper is started and dosn't write the PID quick enough
waitforpidfile() {
        local PIDFILE="$1"
        for i in $(seq 10); do
                if test -s "$PIDFILE"; then
                        return 0
                fi
                sleep 1
        done
        msgdie "waiting for $PIDFILE failed"
        return 1
}

changetowebserver() {
	if [ "$1" != '--no-rewrite' ]; then
		rewritesourceslist 'http://localhost:8080/'
	else
		shift
	fi
	if test -x "${APTWEBSERVERBINDIR}/aptwebserver"; then
		cd aptarchive
		local LOG="webserver.log"
		if ! aptwebserver -o aptwebserver::fork=1 "$@" >$LOG 2>&1 ; then
			cat $LOG
			false
		fi
                waitforpidfile aptwebserver.pid
		local PID="$(cat aptwebserver.pid)"
		if [ -z "$PID" ]; then
			msgdie 'Could not fork aptwebserver successfully'
		fi
		addtrap "kill $PID;"
		cd - > /dev/null
	else
		msgdie 'You have to build aptwerbserver or install a webserver'
	fi
}

changetohttpswebserver() {
	if ! which stunnel4 >/dev/null; then
		msgdie 'You need to install stunnel4 for https testcases'
	fi
	if [ ! -e "${TMPWORKINGDIRECTORY}/aptarchive/aptwebserver.pid" ]; then
		changetowebserver --no-rewrite "$@"
	fi
	echo "pid = ${TMPWORKINGDIRECTORY}/aptarchive/stunnel.pid
cert = ${TMPWORKINGDIRECTORY}/rootdir/etc/webserver.pem
output = /dev/null

[https]
accept = 4433
connect = 8080
" > "${TMPWORKINGDIRECTORY}/stunnel.conf"
	stunnel4 "${TMPWORKINGDIRECTORY}/stunnel.conf"
        waitforpidfile "${TMPWORKINGDIRECTORY}/aptarchive/stunnel.pid"
	local PID="$(cat "${TMPWORKINGDIRECTORY}/aptarchive/stunnel.pid")"
        if [ -z "$PID" ]; then
		msgdie 'Could not fork stunnel4 successfully'
	fi
	addtrap 'prefix' "kill ${PID};"
	rewritesourceslist 'https://localhost:4433/'
}

changetocdrom() {
	mkdir -p rootdir/media/cdrom/.disk
	local CD="$(readlink -f rootdir/media/cdrom)"
	cat > rootdir/etc/apt/apt.conf.d/00cdrom <<EOF
acquire::cdrom::mount "${CD}";
acquire::cdrom::"${CD}/"::mount "mv ${CD}-unmounted ${CD}";
acquire::cdrom::"${CD}/"::umount "mv ${CD} ${CD}-unmounted";
acquire::cdrom::autodetect 0;
EOF
	echo -n "$1" > "${CD}/.disk/info"
	if [ ! -d aptarchive/dists ]; then
		msgdie 'Flat file archive cdroms can not be created currently'
		return 1
	fi
	mv aptarchive/dists "$CD"
	ln -s "$(readlink -f ./incoming)" "$CD/pool"
	find rootdir/etc/apt/sources.list.d/ -name 'apt-test-*.list' -delete
	# start with an unmounted disk
	mv "${CD}" "${CD}-unmounted"
	# we don't want the disk to be modifiable
	addtrap 'prefix' "chmod -f -R +w \"$PWD/rootdir/media/cdrom/dists/\" \"$PWD/rootdir/media/cdrom-unmounted/dists/\" || true;"
	chmod -R 555 rootdir/media/cdrom-unmounted/dists
}

downloadfile() {
	local PROTO="${1%%:*}"
	if ! apthelper -o Debug::Acquire::${PROTO}=1 -o Debug::pkgAcquire::Worker=1 \
		download-file "$1" "$2" "$3" 2>&1 ; then
		return 1
	fi
	# only if the file exists the download was successful
	if [ -r "$2" ]; then
		return 0
	else
		return 1
	fi
}

checkdiff() {
	local DIFFTEXT="$(command diff -u "$@" 2>&1 | sed -e '/^---/ d' -e '/^+++/ d' -e '/^@@/ d')"
	if [ -n "$DIFFTEXT" ]; then
		echo >&2
		echo >&2 "$DIFFTEXT"
		return 1
	else
		return 0
	fi
}

testoutputequal() {
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testoutputequal.output"
	local COMPAREFILE="$1"
	shift
	if "$@" 2>&1 | checkdiff "$COMPAREFILE" - >"$OUTPUT" 2>&1; then
		msgpass
	else
		echo "=== content of file we compared with (${COMPAREFILE}) ===" >>"${OUTPUT}"
		cat "$COMPAREFILE" >>"${OUTPUT}"
		msgfailoutput '' "$OUTPUT" "$@"
	fi
}

testfileequal() {
	msggroup 'testfileequal'
	local MSG='Test for correctness of file'
	if [ "$1" = '--nomsg' ]; then
		MSG=''
		shift
	fi
	local FILE="$1"
	shift
	if [ -n "$MSG" ]; then
		msgtest "$MSG" "$FILE"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testfileequal.output"
	if [ -z "$*" ]; then
		testoutputequal "$FILE" echo -n ''
	else
		testoutputequal "$FILE" echo "$*"
	fi
	msggroup
}

testempty() {
	msggroup 'testempty'
	msgtest "Test for no output of" "$*"
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testempty.comparefile"
	if ("$@" >"$COMPAREFILE" 2>&1 || true) && test ! -s "$COMPAREFILE"; then
		msgpass
	else
		msgfailoutput '' "$COMPAREFILE" "$@"
	fi
	aptautotest 'testempty' "$@"
	msggroup
}
testnotempty() {
	msggroup 'testnotempty'
	msgtest "Test for some output of" "$*"
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testnotempty.comparefile"
	if ("$@" >"$COMPAREFILE" 2>&1 || true) && test -s "$COMPAREFILE"; then
		msgpass
	else
		msgfailoutput '' "$COMPAREFILE" "$@"
	fi
	aptautotest 'testnotempty' "$@"
	msggroup
}

testequal() {
	msggroup 'testequal'
	local MSG='Test of equality of'
	if [ "$1" = '--nomsg' ]; then
		MSG=''
		shift
	fi

	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequal.comparefile"
	echo "$1" > "$COMPAREFILE"
	shift

	if [ -n "$MSG" ]; then
		msgtest "$MSG" "$*"
	fi
	testoutputequal "$COMPAREFILE" "$@"
	aptautotest 'testequal' "$@"
	msggroup
}

testequalor2() {
	msggroup 'testequalor2'
	local COMPAREFILE1="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.comparefile1"
	local COMPAREFILE2="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.comparefile2"
	local COMPAREAGAINST="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.compareagainst"
	echo "$1" > "$COMPAREFILE1"
	echo "$2" > "$COMPAREFILE2"
	shift 2
	msgtest "Test for equality OR of" "$*"
	"$@" >"$COMPAREAGAINST" 2>&1 || true
	if checkdiff "$COMPAREFILE1" "$COMPAREAGAINST" >/dev/null 2>&1 || \
		checkdiff "$COMPAREFILE2" "$COMPAREAGAINST" >/dev/null 2>&1
	then
		msgpass
	else
		local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequal.output"
		echo -n "\n${CINFO}Diff against OR 1${CNORMAL}" >"$OUTPUT" 2>&1
		checkdiff "$COMPAREFILE1" "$COMPAREAGAINST" >"$OUTPUT" 2>&1 || true
		echo -n "${CINFO}Diff against OR 2${CNORMAL}" >"$OUTPUT" 2>&1
		checkdiff "$COMPAREFILE2" "$COMPAREAGAINST" >"$OUTPUT" 2>&1 || true
		msgfailoutput '' "$OUTPUT"
	fi
	aptautotest 'testequalor2' "$@"
	msggroup
}

testshowvirtual() {
	msggroup 'testshowvirtual'
	local VIRTUAL="N: Can't select versions from package '$1' as it is purely virtual"
	local PACKAGE="$1"
	shift
	while [ -n "$1" ]; do
		VIRTUAL="${VIRTUAL}
N: Can't select versions from package '$1' as it is purely virtual"
		PACKAGE="${PACKAGE} $1"
		shift
	done
	msgtest "Test for virtual packages" "apt-cache show $PACKAGE"
	VIRTUAL="${VIRTUAL}
N: No packages found"
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testshowvirtual.comparefile"
	local ARCH="$(getarchitecture 'native')"
	echo "$VIRTUAL" | sed -e "s/:$ARCH//" -e 's/:all//' >"$COMPAREFILE"
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testshowvirtual.output"
	testoutputequal "$COMPAREFILE" aptcache show -q=0 "$PACKAGE"
	msggroup
}

testnopackage() {
	msggroup 'testnopackage'
	msgtest "Test for non-existent packages" "apt-cache show $*"
	local SHOWPKG="$(aptcache show "$@" 2>&1 | grep '^Package: ')"
	if [ -n "$SHOWPKG" ]; then
		local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testnopackage.output"
		echo "$SHOWPKG" >"$OUTPUT"
		msgfailoutput '' "$OUTPUT"
	else
		msgpass
	fi
	msggroup
}

testdpkgstatus() {
	msggroup 'testdpkgstatus'
	local STATE="$1"
	local NR="$2"
	shift 2
	msgtest "Test that $NR package(s) are in state $STATE with" "dpkg -l $*"
	local PKGS="$(dpkg -l "$@" 2>/dev/null | grep "^${STATE}" | wc -l)"
	if [ "$PKGS" != $NR ]; then
		local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testnopackage.output"
		echo "$PKGS" >"$OUTPUT"
		dpkg -l "$@" | grep '^[a-z]' >"$OUTPUT" >&2 || true
		msgfailoutput '' "$OUTPUT"
	else
		msgpass
	fi
	msggroup
}

testdpkginstalled() {
	msggroup 'testdpkginstalled'
	testdpkgstatus 'ii' "$#" "$@"
	msggroup
}

testdpkgnotinstalled() {
	msggroup 'testdpkgnotinstalled'
	testdpkgstatus 'ii' '0' "$@"
	msggroup
}

testmarkedauto() {
	msggroup 'testmarkedauto'
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testmarkedauto.comparefile"
	if [ -n "$1" ]; then
		msgtest 'Test for correctly marked as auto-installed' "$*"
		while [ -n "$1" ]; do echo "$1"; shift; done | sort > "$COMPAREFILE"
	else
		msgtest 'Test for correctly marked as auto-installed' 'no package'
		echo -n > "$COMPAREFILE"
	fi
	testoutputequal "$COMPAREFILE" aptmark showauto
	msggroup
}
testmarkedmanual() {
	msggroup 'testmarkedmanual'
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testmarkedmanual.comparefile"
	if [ -n "$1" ]; then
		msgtest 'Test for correctly marked as manually installed' "$*"
		while [ -n "$1" ]; do echo "$1"; shift; done | sort > "$COMPAREFILE"
	else
		msgtest 'Test for correctly marked as manually installed' 'no package'
		echo -n > "$COMPAREFILE"
	fi
	testoutputequal "$COMPAREFILE" aptmark showmanual
	msggroup
}

msgfailoutput() {
	msgreportheader 'msgfailoutput'
	local MSG="$1"
	local OUTPUT="$2"
	shift 2
	if [ "$1" = 'grep' ]; then
		echo >&2
		while [ -n "$2" ]; do shift; done
		echo "#### Complete file: $1 ####"
		cat >&2 "$1" || true
		echo '#### grep output ####'
	elif [ "$1" = 'test' ]; then
		echo >&2
		# doesn't support ! or non-file flags
		msgfailoutputstatfile() {
			local FILEFLAGS='^-[bcdefgGhkLOprsStuwx]$'
			if expr match "$1" "$FILEFLAGS" >/dev/null; then
				echo "#### stat(2) of file: $2 ####"
				stat "$2" || true
				if test -e "$2"; then
					echo "#### Complete file: $2 ####"
					cat >&2 "$2" || true
				fi
			fi
		}
		msgfailoutputstatfile "$2" "$3"
		while [ -n "$5" ] && [ "$4" = '-o' -o "$4" = '-a' ]; do
			shift 3
			msgfailoutputstatfile "$2" "$3"
		done
		echo '#### test output ####'
	fi
	cat >&2 "$OUTPUT"
	msgfail "$MSG"
}

testsuccess() {
	msggroup 'testsuccess'
	if [ "$1" = '--nomsg' ]; then
		shift
	else
		msgtest 'Test for successful execution of' "$*"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testsuccess.output"
	if "$@" >"${OUTPUT}" 2>&1; then
		if expr match "$1" '^apt.*' >/dev/null; then
			if grep -q -E ' runtime error: ' "$OUTPUT"; then
				msgfailoutput 'compiler detected undefined behavior' "$OUTPUT" "$@"
			elif grep -E '^[WE]: ' "$OUTPUT" > "${TMPWORKINGDIRECTORY}/rootdir/tmp/checkforwarnings.output" 2>&1; then
				if [ "$IGNORE_PTY_NOT_MOUNTED" = '1' ]; then
					if echo 'E: Can not write log (Is /dev/pts mounted?) - posix_openpt (2: No such file or directory)' \
						| cmp - "${TMPWORKINGDIRECTORY}/rootdir/tmp/checkforwarnings.output" >/dev/null 2>&1; then
						msgpass
					else
						msgfailoutput 'successful run, but output contains warnings/errors' "$OUTPUT" "$@"
					fi
				else
					msgfailoutput 'successful run, but output contains warnings/errors' "$OUTPUT" "$@"
				fi
			else
				msgpass
			fi
		else
			msgpass
		fi
	else
		local EXITCODE=$?
		msgfailoutput "exitcode $EXITCODE" "$OUTPUT" "$@"
	fi
	aptautotest 'testsuccess' "$@"
	msggroup
}
testwarning() {
	msggroup 'testwarning'
	if [ "$1" = '--nomsg' ]; then
		shift
	else
		msgtest 'Test for successful execution with warnings of' "$*"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testwarning.output"
	if "$@" >"${OUTPUT}" 2>&1; then
		if expr match "$1" '^apt.*' >/dev/null; then
			if grep -q -E ' runtime error: ' "$OUTPUT"; then
				msgfailoutput 'compiler detected undefined behavior' "$OUTPUT" "$@"
			elif grep -q -E '^E: ' "$OUTPUT"; then
				msgfailoutput 'successful run, but output contains errors' "$OUTPUT" "$@"
			elif ! grep -q -E '^W: ' "$OUTPUT"; then
				msgfailoutput 'successful run, but output contains no warnings' "$OUTPUT" "$@"
			else
				msgpass
			fi
		else
			msgpass
		fi
	else
		local EXITCODE=$?
		msgfailoutput "exitcode $EXITCODE" "$OUTPUT" "$@"
	fi
	aptautotest 'testwarning' "$@"
	msggroup
}
testfailure() {
	msggroup 'testfailure'
	if [ "$1" = '--nomsg' ]; then
		shift
	else
		msgtest 'Test for failure in execution of' "$*"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailure.output"
	if "$@" >"${OUTPUT}" 2>&1; then
		local EXITCODE=$?
		msgfailoutput "exitcode $EXITCODE" "$OUTPUT" "$@"
	else
		local EXITCODE=$?
		if expr match "$1" '^apt.*' >/dev/null; then
			if [ "$1" = 'aptkey' ]; then
				if grep -q -E " Can't check signature: " "$OUTPUT" || \
					grep -q -E " BAD signature from " "$OUTPUT"; then
					msgpass
				else
					msgfailoutput "run failed with exitcode ${EXITCODE}, but no signature error" "$OUTPUT" "$@"
				fi
			else
				if grep -q -E ' runtime error: ' "$OUTPUT"; then
					msgfailoutput 'compiler detected undefined behavior' "$OUTPUT" "$@"
				elif grep -q -E '==ERROR' "$OUTPUT"; then
					msgfailoutput 'compiler sanitizers reported errors' "$OUTPUT" "$@"
				elif ! grep -q -E '^E: ' "$OUTPUT"; then
					msgfailoutput "run failed with exitcode ${EXITCODE}, but with no errors" "$OUTPUT" "$@"
				else
					msgpass
				fi
			fi
		else
			msgpass
		fi
	fi
	aptautotest 'testfailure' "$@"
	msggroup
}

testreturnstateequal() {
	local STATE="$1"
	msggroup "${STATE}equal"
	if [ "$2" != '--nomsg' ]; then
		local CMP="$2"
		shift 2
		"$STATE" "$@"
		testfileequal "${TMPWORKINGDIRECTORY}/rootdir/tmp/${STATE}.output" "$CMP"
	else
		local CMP="$3"
		shift 3
		"$STATE" --nomsg "$@"
		testfileequal "${TMPWORKINGDIRECTORY}/rootdir/tmp/${STATE}.output" "$CMP"
	fi
	msggroup
}
testsuccessequal() {
	testreturnstateequal 'testsuccess' "$@"
}
testwarningequal() {
	testreturnstateequal 'testwarning' "$@"
}
testfailureequal() {
	testreturnstateequal 'testfailure' "$@"
}

testfailuremsg() {
	msggroup 'testfailuremsg'
	local CMP="$1"
	shift
	testfailure "$@"
	msgtest 'Check that the output of the previous failed command has expected' 'failures and warnings'
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailuremsg.comparefile"
	grep '^\(W\|E\):' "${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailure.output" > "$COMPAREFILE" 2>&1 || true
	testoutputequal "$COMPAREFILE" echo "$CMP"
	msggroup
}

testfilestats() {
	msggroup 'testfilestats'
	msgtest "Test that file $1 has $2 $3" "$4"
	if [ "$4" "$3" "$(stat --format "$2" "$1")" ]; then
		msgpass
	else
		local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testfilestats.output"
		{
			ls -ld "$1" || true
			echo -n "stat(1) reports for $2: "
			stat --format "$2" "$1" || true
		} >"$OUTPUT" 2>&1
		msgfailoutput '' "$OUTPUT"
	fi
	msggroup
}
testaccessrights() {
	msggroup 'testaccessrights'
	testfilestats "$1" '%a' '=' "$2"
	msggroup
}

testwebserverlaststatuscode() {
	msggroup 'testwebserverlaststatuscode'
	local DOWNLOG='rootdir/tmp/webserverstatus-testfile.log'
	local STATUS='downloaded/webserverstatus-statusfile.log'
	rm -f "$DOWNLOG" "$STATUS"
	msgtest 'Test last status code from the webserver was' "$1"
	if downloadfile "http://localhost:8080/_config/find/aptwebserver::last-status-code" "$STATUS" > "$DOWNLOG" && [ "$(cat "$STATUS")" = "$1" ]; then
		msgpass
	else
		local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testwebserverlaststatuscode.output"
		{
			if [ -n "$2" ]; then
				shift
				echo >&2 '#### Additionally provided output files contain:'
				cat >&2 "$@"
			fi
			echo >&2 '#### Download log of the status code:'
			cat >&2 "$DOWNLOG"
		} >"$OUTPUT" 2>&1
		msgfailoutput "Status was $(cat "$STATUS")" "$OUTPUT"
	fi
	msggroup
}

pause() {
	echo "STOPPED execution. Press enter to continue"
	local IGNORE
	read IGNORE
}

listcurrentlistsdirectory() {
	{
		find rootdir/var/lib/apt/lists -maxdepth 1 -type d | while read line; do
			stat --format '%U:%G:%a:%n' "$line"
		done
		find rootdir/var/lib/apt/lists -maxdepth 1 \! -type d | while read line; do
			stat --format '%U:%G:%a:%s:%y:%n' "$line"
		done
	} | sort
}

### convenience hacks ###
mkdir() {
	# creating some directories by hand is a tedious task, so make it look simple
	if [ "$*" = '-p rootdir/var/lib/apt/lists' ] || [ "$*" = "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists" ] ||
	   [ "$*" = '-p rootdir/var/lib/apt/lists/partial' ] || [ "$*" = "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/partial" ]; then
		# only the last directory created by mkdir is effected by the -m !
		command mkdir -m 755 -p "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt"
		command mkdir -m 755 -p "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists"
		command mkdir -m 700 -p "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/partial"
		touch "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/lock"
		if [ "$(id -u)" = '0' ]; then
			chown _apt:root "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/partial"
		fi
	else
		command mkdir "$@"
	fi
}

### The following tests are run by most test methods automatically to check
### general things about commands executed without writing the test every time.

aptautotest() {
	local TESTCALL="$1"
	local CMD="$2"
	local FIRSTOPT="$3"
	local AUTOTEST="aptautotest_$(echo "${CMD##*/}_${FIRSTOPT}" | tr -d '-')"
	if command -v $AUTOTEST >/dev/null; then
		shift 3
		# save and restore the *.output files from other tests
		# as we might otherwise override them in these automatic tests
		rm -rf "${TMPWORKINGDIRECTORY}/rootdir/tmp-before"
		mv "${TMPWORKINGDIRECTORY}/rootdir/tmp" "${TMPWORKINGDIRECTORY}/rootdir/tmp-before"
		mkdir "${TMPWORKINGDIRECTORY}/rootdir/tmp"
		$AUTOTEST "$TESTCALL" "$@"
		rm -rf "${TMPWORKINGDIRECTORY}/rootdir/tmp-aptautotest"
		mv "${TMPWORKINGDIRECTORY}/rootdir/tmp" "${TMPWORKINGDIRECTORY}/rootdir/tmp-aptautotest"
		mv "${TMPWORKINGDIRECTORY}/rootdir/tmp-before" "${TMPWORKINGDIRECTORY}/rootdir/tmp"
	fi
}

aptautotest_aptget_update() {
	local TESTCALL="$1"
	while [ -n "$2" ]; do
		if [ "$2" = '--print-uris' ]; then return; fi # simulation mode
		shift
	done
	if ! test -d "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists"; then return; fi
	testfilestats "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt" '%U:%G:%a' '=' "${TEST_DEFAULT_USER}:${TEST_DEFAULT_GROUP}:755"
	testfilestats "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists" '%U:%G:%a' '=' "${TEST_DEFAULT_USER}:${TEST_DEFAULT_GROUP}:755"
	# all copied files are properly chmodded
	local backupIFS="$IFS"
	IFS="$(printf "\n\b")"
	for file in $(find "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists" -type f ! -name 'lock'); do
		testfilestats "$file" '%U:%G:%a' '=' "${TEST_DEFAULT_USER}:${TEST_DEFAULT_GROUP}:644"
	done
	IFS="$backupIFS"
	if [ "$TESTCALL" = 'testsuccess' ]; then
		# failure cases can retain partial files and such
		testempty find "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/partial" -mindepth 1 ! \( -name 'lock' -o -name '*.FAILED' \)
	fi
}
aptautotest_apt_update() { aptautotest_aptget_update "$@"; }
aptautotest_aptcdrom_add() { aptautotest_aptget_update "$@"; }

testaptautotestnodpkgwarning() {
	local TESTCALL="$1"
	while [ -n "$2" ]; do
		if expr match "$2" '^-[a-z]*s' >/dev/null 2>&1; then return; fi # simulation mode
		if expr match "$2" '^-dy\?' >/dev/null 2>&1; then return; fi # download-only mode
		shift
	done
	testfailure grep '^dpkg: warning:.*ignor.*' "${TMPWORKINGDIRECTORY}/rootdir/tmp-before/${TESTCALL}.output"
}

aptautotest_aptget_install() { testaptautotestnodpkgwarning "$@"; }
aptautotest_aptget_remove() { testaptautotestnodpkgwarning "$@"; }
aptautotest_aptget_purge() { testaptautotestnodpkgwarning "$@"; }
aptautotest_apt_install() { testaptautotestnodpkgwarning "$@"; }
aptautotest_apt_remove() { testaptautotestnodpkgwarning "$@"; }
aptautotest_apt_purge() { testaptautotestnodpkgwarning "$@"; }
