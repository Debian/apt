#!/bin/sh -- # no runable script, just for vi

EXIT_CODE=0

# we all like colorful messages
if [ "$MSGCOLOR" != 'NO' ] && [ "$MSGCOLOR" != 'ALWAYS' ]; then
	if [ ! -t 1 ]; then # but check that we output to a terminal
		export MSGCOLOR='NO'
	fi
fi


if [ "$MSGCOLOR" != 'NO' ]; then
	CERROR="\033[1;31m" # red
	CWARNING="\033[1;33m" # yellow
	CMSG="\033[1;32m" # green
	CINFO="\033[1;96m" # light blue
	CDEBUG="\033[1;94m" # blue
	CNORMAL="\033[0;39m" # default system console color
	CDONE="\033[1;32m" # green
	CPASS="\033[1;32m" # green
	CFAIL="\033[1;31m" # red
	CCMD="\033[1;35m" # pink
fi

msgprintf() {
	local START="$1"
	local MIDDLE="$2"
	local END="$3"
	shift 3
	if [ -n "$1" ]; then
		printf "$START " "$1"
		shift
		while [ -n "$1" ]; do
			printf "$MIDDLE " "$(echo "$1" | sed -e 's#^apt\([cfghs]\)#apt-\1#')"
			shift
		done
	fi
	printf "${END}"
}
msgdie() { msgprintf "${CERROR}E: %s" '%s' "${CNORMAL}\n" "$@" >&2; exit 1; }
msgwarn() { msgprintf "${CWARNING}W: %s" '%s' "${CNORMAL}\n" "$@" >&2; }
msgmsg() { msgprintf "${CMSG}%s" '%s' "${CNORMAL}\n" "$@"; }
msginfo() { msgprintf "${CINFO}I: %s" '%s' "${CNORMAL}\n" "$@"; }
msgdebug() { msgprintf "${CDEBUG}D: %s" '%s' "${CNORMAL}\n" "$@"; }
msgdone() { msgprintf "${CDONE}DONE" '%s' "${CNORMAL}\n" "$@"; }
msgnwarn() { msgprintf "${CWARNING}W: %s" '%s' "${CNORMAL}" "$@" >&2; }
msgnmsg() { msgprintf "${CMSG}%s" '%s' "${CNORMAL}" "$@"; }
msgninfo() { msgprintf "${CINFO}I: %s" '%s' "${CNORMAL}" "$@"; }
msgndebug() { msgprintf "${CDEBUG}D: %s" '%s' "${CNORMAL}" "$@"; }
msgtest() { msgprintf "${CINFO}%s" "${CCMD}%s${CINFO}" "…${CNORMAL} " "$@"; }
msgpass() { printf "${CPASS}PASS${CNORMAL}\n"; }
msgskip() {
	if [ $# -gt 0 ]; then printf "${CWARNING}SKIP: $*${CNORMAL}\n" >&2;
	else printf "${CWARNING}SKIP${CNORMAL}\n" >&2; fi
}
msgfail() {
	if [ $# -gt 0 ]; then printf "${CFAIL}FAIL: $*${CNORMAL}\n" >&2;
	else printf "${CFAIL}FAIL${CNORMAL}\n" >&2; fi
	if [ -n "$APT_DEBUG_TESTS" ]; then
		$SHELL
	fi
	EXIT_CODE=$((EXIT_CODE+1));
}

# enable / disable Debugging
MSGLEVEL=${MSGLEVEL:-3}
if [ $MSGLEVEL -le 0 ]; then
	msgdie() { true; }
fi
if [ $MSGLEVEL -le 1 ]; then
	msgwarn() { true; }
	msgnwarn() { true; }
fi
if [ $MSGLEVEL -le 2 ]; then
	msgmsg() { true; }
	msgnmsg() { true; }
	msgtest() { true; }
	msgpass() { printf " ${CPASS}P${CNORMAL}"; }
fi
if [ $MSGLEVEL -le 3 ]; then
	msginfo() { true; }
	msgninfo() { true; }
fi
if [ $MSGLEVEL -le 4 ]; then
	msgdebug() { true; }
	msgndebug() { true; }
fi
msgdone() {
	if [ "$1" = "debug" -a $MSGLEVEL -le 4 ] ||
	   [ "$1" = "info" -a $MSGLEVEL -le 3 ] ||
	   [ "$1" = "msg" -a $MSGLEVEL -le 2 ] ||
	   [ "$1" = "warn" -a $MSGLEVEL -le 1 ] ||
	   [ "$1" = "die" -a $MSGLEVEL -le 0 ]; then
		true;
	else
		printf "${CDONE}DONE${CNORMAL}\n";
	fi
}
getaptconfig() {
	if [ -f ./aptconfig.conf ]; then
            echo "./aptconfig.conf"
	elif [ -f ../aptconfig.conf ]; then
            echo "../aptconfig.conf"
        fi
}
runapt() {
	msgdebug "Executing: ${CCMD}$*${CDEBUG} "
	local CMD="$1"
	shift
	case $CMD in
	sh|aptitude|*/*|command) ;;
	*) CMD="${BUILDDIRECTORY}/$CMD";;
	esac
	MALLOC_PERTURB_=21 MALLOC_CHECK_=2 APT_CONFIG="$(getaptconfig)" LD_LIBRARY_PATH=${LIBRARYPATH} $CMD "$@"
}
aptconfig() { runapt apt-config "$@"; }
aptcache() { runapt apt-cache "$@"; }
aptcdrom() { runapt apt-cdrom "$@"; }
aptget() { runapt apt-get "$@"; }
aptftparchive() { runapt apt-ftparchive "$@"; }
aptkey() { runapt apt-key "$@"; }
aptmark() { runapt apt-mark "$@"; }
aptsortpkgs() { runapt apt-sortpkgs "$@"; }
apt() { runapt apt "$@"; }
apthelper() { runapt "${APTHELPERBINDIR}/apt-helper" "$@"; }
aptwebserver() { runapt "${APTWEBSERVERBINDIR}/aptwebserver" "$@"; }
aptitude() { runapt aptitude "$@"; }
aptextracttemplates() { runapt apt-extracttemplates "$@"; }
aptinternalsolver() { runapt "${APTINTERNALSOLVER}" "$@"; }
aptdumpsolver() { runapt "${APTDUMPSOLVER}" "$@"; }

dpkg() {
	"${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg" "$@"
}
dpkgcheckbuilddeps() {
	command dpkg-checkbuilddeps --admindir=${TMPWORKINGDIRECTORY}/rootdir/var/lib/dpkg "$@"
}
gdb() {
	local CMD="$1"
	shift
	runapt command gdb --quiet -ex run "${BUILDDIRECTORY}/$CMD" --args "${BUILDDIRECTORY}/$CMD" "$@"
}

exitwithstatus() {
        # error if we about to overflow, but ...
        #   "255 failures ought to be enough for everybody"
        if [ $EXIT_CODE -gt 255 ]; then
            msgdie "Total failure count $EXIT_CODE too big"
        fi
        exit $((EXIT_CODE <= 255 ? EXIT_CODE : 255));
}

shellsetedetector() {
	local exit_status=$?
	if [ "$exit_status" != '0' ]; then
		printf >&2 "${CERROR}E: Looks like the testcases ended prematurely with exitcode: ${exit_status}${CNORMAL}\n"
		if [ "$EXIT_CODE" = '0' ]; then
			EXIT_CODE="$exit_status"
		fi
	fi
}

addtrap() {
	if [ "$1" = 'prefix' ]; then
		CURRENTTRAP="$2 $CURRENTTRAP"
	else
		CURRENTTRAP="$CURRENTTRAP $1"
	fi
	trap "shellsetedetector; $CURRENTTRAP exitwithstatus;" 0 HUP INT QUIT ILL ABRT FPE SEGV PIPE TERM
}

setupenvironment() {
	# privilege dropping and testing doesn't work if /tmp isn't world-writeable (as e.g. with libpam-tmpdir)
	if [ -n "$TMPDIR" ] && [ "$(id -u)" = '0' ] && [ "$(stat --format '%a' "$TMPDIR")" != '1777' ]; then
		unset TMPDIR
	fi
	TMPWORKINGDIRECTORY=$(mktemp -d)
	addtrap "cd /; rm -rf $TMPWORKINGDIRECTORY;"
	msgninfo "Preparing environment for ${CCMD}$(basename $0)${CINFO} in ${TMPWORKINGDIRECTORY}… "

	mkdir -m 700 "${TMPWORKINGDIRECTORY}/downloaded"
	if [ "$(id -u)" = '0' ]; then
		# relax permissions so that running as root with user switching works
		umask 022
		chmod 711 "$TMPWORKINGDIRECTORY"
		chown _apt:root "${TMPWORKINGDIRECTORY}/downloaded"
	fi

	TESTDIRECTORY=$(readlink -f $(dirname $0))
        # allow overriding the default BUILDDIR location
	SOURCEDIRECTORY=${APT_INTEGRATION_TESTS_SOURCE_DIR:-"${TESTDIRECTORY}/../../"}
	BUILDDIRECTORY=${APT_INTEGRATION_TESTS_BUILD_DIR:-"${TESTDIRECTORY}/../../build/bin"}
	LIBRARYPATH=${APT_INTEGRATION_TESTS_LIBRARY_PATH:-"${BUILDDIRECTORY}"}
        METHODSDIR=${APT_INTEGRATION_TESTS_METHODS_DIR:-"${BUILDDIRECTORY}/methods"}
        APTHELPERBINDIR=${APT_INTEGRATION_TESTS_LIBEXEC_DIR:-"${BUILDDIRECTORY}"}
        APTWEBSERVERBINDIR=${APT_INTEGRATION_TESTS_WEBSERVER_BIN_DIR:-"${BUILDDIRECTORY}"}
        APTINTERNALSOLVER=${APT_INTEGRATION_TESTS_INTERNAL_SOLVER:-"${BUILDDIRECTORY}/apt-internal-solver"}
	APTDUMPSOLVER=${APT_INTEGRATION_TESTS_DUMP_SOLVER:-"${BUILDDIRECTORY}/apt-dump-solver"}
	test -x "${BUILDDIRECTORY}/apt-get" || msgdie "You need to build tree first"
        # -----

	cd $TMPWORKINGDIRECTORY
	mkdir rootdir aptarchive keys
	cd rootdir
	mkdir -p etc/apt/apt.conf.d etc/apt/sources.list.d etc/apt/trusted.gpg.d etc/apt/preferences.d
	mkdir -p usr/bin var/cache var/lib var/log tmp
	mkdir -p var/lib/dpkg/info var/lib/dpkg/updates var/lib/dpkg/triggers
	touch var/lib/dpkg/available
	mkdir -p usr/lib/apt
	ln -s ${METHODSDIR} usr/lib/apt/methods
	if [ "$BUILDDIRECTORY" = "$LIBRARYPATH" ]; then
		mkdir -p usr/lib/apt/solvers
		ln -s "${BUILDDIRECTORY}/apt-dump-solver" usr/lib/apt/solvers/dump
		ln -s "${BUILDDIRECTORY}/apt-internal-solver" usr/lib/apt/solvers/apt
		echo "Dir::Bin::Solvers \"${TMPWORKINGDIRECTORY}/rootdir/usr/lib/apt/solvers\";" > etc/apt/apt.conf.d/externalsolver.conf
	fi
        # use the autoremove from the BUILDDIRECTORY if its there, otherwise
        # system
        if [ -e ${BUILDDIRECTORY}/../../debian/apt.conf.autoremove ]; then
	    ln -s ${BUILDDIRECTORY}/../../debian/apt.conf.autoremove etc/apt/apt.conf.d/01autoremove
        else
	    ln -s /etc/apt/apt.conf.d/01autoremove etc/apt/apt.conf.d/01autoremove
        fi
	cd ..
	local PACKAGESFILE=$(echo "$(basename $0)" | sed -e 's/^test-/Packages-/' -e 's/^skip-/Packages-/')
	if [ -f "${TESTDIRECTORY}/${PACKAGESFILE}" ]; then
		cp "${TESTDIRECTORY}/${PACKAGESFILE}" aptarchive/Packages
	fi
	local SOURCESSFILE=$(echo "$(basename $0)" | sed -e 's/^test-/Sources-/' -e 's/^skip-/Sources-/')
	if [ -f "${TESTDIRECTORY}/${SOURCESSFILE}" ]; then
		cp "${TESTDIRECTORY}/${SOURCESSFILE}" aptarchive/Sources
	fi
	cp $(find $TESTDIRECTORY -name '*.pub' -o -name '*.sec') keys/
	chmod 644 $(find keys -name '*.pub' -o -name '*.sec')
	ln -s ${TMPWORKINGDIRECTORY}/keys/joesixpack.pub rootdir/etc/apt/trusted.gpg.d/joesixpack.gpg

	echo "Dir \"${TMPWORKINGDIRECTORY}/rootdir\";" > aptconfig.conf
	echo "Dir::state::status \"${TMPWORKINGDIRECTORY}/rootdir/var/lib/dpkg/status\";" >> aptconfig.conf
	echo "APT::Get::Show-User-Simulation-Note \"false\";" >> aptconfig.conf
	echo "Dir::Bin::Methods \"${METHODSDIR}\";" >> aptconfig.conf
	# store apt-key were we can access it, even if we run it as a different user
	# destroys coverage reporting though, so just do it for root for now
	if [ "$(id -u)" = '0' ]; then
		cp "${BUILDDIRECTORY}/apt-key" "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/"
		chmod o+rx "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/apt-key"
		echo "Dir::Bin::apt-key \"${TMPWORKINGDIRECTORY}/rootdir/usr/bin/apt-key\";" >> aptconfig.conf
	else
		echo "Dir::Bin::apt-key \"${BUILDDIRECTORY}/apt-key\";" >> aptconfig.conf
	fi

	cat << EOF > "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg"
#!/bin/sh
set -e
if [ -r "${TMPWORKINGDIRECTORY}/noopchroot.so" ]; then
	if [ -n "\$LD_PRELOAD" ]; then
		export LD_PRELOAD="${TMPWORKINGDIRECTORY}/noopchroot.so \${LD_PRELOAD}"
	else
		export LD_PRELOAD="${TMPWORKINGDIRECTORY}/noopchroot.so"
	fi
fi
exec fakeroot dpkg --root="${TMPWORKINGDIRECTORY}/rootdir" \\
	--log=${TMPWORKINGDIRECTORY}/rootdir/var/log/dpkg.log \\
	--force-not-root --force-bad-path "\$@"
EOF
	chmod +x "${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg"
	echo "Dir::Bin::dpkg \"${TMPWORKINGDIRECTORY}/rootdir/usr/bin/dpkg\";" > rootdir/etc/apt/apt.conf.d/99dpkg

	if ! command dpkg --assert-multi-arch >/dev/null 2>&1; then
		echo "DPKG::options:: \"--force-architecture\";" >> aptconfig.conf # Added to test multiarch before dpkg is ready for it…
	fi
	echo 'quiet::NoUpdate "true";' >> aptconfig.conf
	echo 'quiet::NoStatistic "true";' >> aptconfig.conf
	# too distracting for users, but helpful to detect changes
	echo 'Acquire::Progress::Ignore::ShowErrorText "true";' >> aptconfig.conf
	# in testcases, it can appear as if localhost has a rotation setup,
	# hide this as we can't really deal with it properly
	echo 'Acquire::Failure::ShowIP "false";' >> aptconfig.conf

	cp "${TESTDIRECTORY}/apt.pem" "${TMPWORKINGDIRECTORY}/rootdir/etc/webserver.pem"
	if [ "$(id -u)" = '0' ]; then
		chown _apt:root "${TMPWORKINGDIRECTORY}/rootdir/etc/webserver.pem"
	fi
	echo "Acquire::https::CaInfo \"${TMPWORKINGDIRECTORY}/rootdir/etc/webserver.pem\";" > rootdir/etc/apt/apt.conf.d/99https
	echo "Apt::Cmd::Disable-Script-Warning \"1\";" > rootdir/etc/apt/apt.conf.d/apt-binary
	configcompression '.' 'gz' #'bz2' 'lzma' 'xz'

	# create some files in /tmp and look at user/group to get what this means
	TEST_DEFAULT_USER="$USER"
	if [ "$(uname)" = 'GNU/kFreeBSD' ]; then
		TEST_DEFAULT_GROUP='root'
	else
		TEST_DEFAULT_GROUP="$USER"
	fi

        # Acquire::AllowInsecureRepositories=false is not yet the default
        # but we want it to be the default soon
        configallowinsecurerepositories "false";

	# cleanup the environment a bit
        # prefer our apt binaries over the system apt binaries
	export PATH="${BUILDDIRECTORY}:${PATH}:/usr/local/sbin:/usr/sbin:/sbin"
	export LC_ALL=C.UTF-8
	unset LANGUAGE APT_CONFIG
	unset GREP_OPTIONS DEB_BUILD_PROFILES

	msgdone "info"
}

getarchitecture() {
	if [ "$1" = "native" -o -z "$1" ]; then
		eval `aptconfig shell ARCH APT::Architecture`
		if [ -n "$ARCH" ]; then
			echo $ARCH
		else
			dpkg --print-architecture
		fi
	else
		echo $1
	fi
}

getarchitectures() {
	aptconfig dump --no-empty --format '%v%n' APT::Architecture APT::Architectures | sort -u | tr '\n' ' '
}

getarchitecturesfromcommalist() {
	echo "$1" | sed -e 's#,#\n#g' | sed -e "s/^native\$/$(getarchitecture 'native')/"
}

configarchitecture() {
	{
		echo "APT::Architecture \"$(getarchitecture $1)\";"
		while [ -n "$1" ]; do
			echo "APT::Architectures:: \"$(getarchitecture $1)\";"
			shift
		done
	} >rootdir/etc/apt/apt.conf.d/01multiarch.conf
	configdpkg
}

configdpkg() {
	if [ ! -e rootdir/var/lib/dpkg/status ]; then
		local STATUSFILE=$(echo "$(basename $0)" | sed -e 's/^test-/status-/' -e 's/^skip-/status-/')
		if [ -f "${TESTDIRECTORY}/${STATUSFILE}" ]; then
			cp "${TESTDIRECTORY}/${STATUSFILE}" rootdir/var/lib/dpkg/status
		else
			echo -n > rootdir/var/lib/dpkg/status
		fi
	fi
	rm -f rootdir/etc/apt/apt.conf.d/00foreigndpkg
	if command dpkg --assert-multi-arch >/dev/null 2>&1 ; then
		local ARCHS="$(getarchitectures)"
		if echo "$ARCHS" | grep -E -q '[^ ]+ [^ ]+'; then
			DPKGARCH="$(dpkg --print-architecture)"
			for ARCH in ${ARCHS}; do
				if [ "${ARCH}" != "${DPKGARCH}" ]; then
					if ! dpkg --add-architecture ${ARCH} >/dev/null 2>&1; then
						# old-style used e.g. in Ubuntu-P – and as it seems travis
						echo "DPKG::options:: \"--foreign-architecture\";" >> rootdir/etc/apt/apt.conf.d/00foreigndpkg
						echo "DPKG::options:: \"${ARCH}\";"  >> rootdir/etc/apt/apt.conf.d/00foreigndpkg
					fi
				fi
			done
			if [ "0" = "$(dpkg -l dpkg 2> /dev/null | grep '^i' | wc -l)" ]; then
				# dpkg doesn't really check the version as long as it is fully installed,
				# but just to be sure we choose one above the required version
				insertinstalledpackage 'dpkg' "all" '1.16.2+fake'
			fi
		fi
	fi
}

configdpkgnoopchroot() {
	# create a library to noop chroot() and rewrite maintainer script executions
	# via execvp() as used by dpkg as we don't want our rootdir to be a fullblown
	# chroot directory dpkg could chroot into to execute the maintainer scripts
	msgtest 'Building library to preload to make maintainerscript work in' 'dpkg'
	cat << EOF > noopchroot.c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>

static char * chrootdir = NULL;

int chroot(const char *path) {
	printf("WARNING: CHROOTing to %s was ignored!\n", path);
	free(chrootdir);
	chrootdir = strdup(path);
	return 0;
}
int execvp(const char *file, char *const argv[]) {
	static int (*func_execvp) (const char *, char * const []) = NULL;
	if (func_execvp == NULL)
		func_execvp = (int (*) (const char *, char * const [])) dlsym(RTLD_NEXT, "execvp");
	if (chrootdir == NULL || strncmp(file, "/var/lib/dpkg/", strlen("/var/lib/dpkg/")) != 0)
		return func_execvp(file, argv);
	printf("REWRITE execvp call %s into %s\n", file, chrootdir);
	char newfile[strlen(chrootdir) + strlen(file)];
	strcpy(newfile, chrootdir);
	strcat(newfile, file);
	char const * const baseadmindir = "/var/lib/dpkg";
	char admindir[strlen(chrootdir) + strlen(baseadmindir)];
	strcpy(admindir, chrootdir);
	strcat(admindir, baseadmindir);
	setenv("DPKG_ADMINDIR", admindir, 1);
	return func_execvp(newfile, argv);
}
EOF
	testsuccess --nomsg gcc -fPIC -shared -o noopchroot.so noopchroot.c -ldl
}

configallowinsecurerepositories() {
    echo "Acquire::AllowInsecureRepositories \"$1\";" >  rootdir/etc/apt/apt.conf.d/allow-insecure-repositories.conf

}

configcompression() {
	while [ -n "$1" ]; do
		case "$1" in
		'.') printf ".\t.\tcat\n";;
		'gz') printf "gzip\tgz\tgzip\n";;
		'bz2') printf "bzip2\tbz2\tbzip2\n";;
		'lzma') printf "lzma\tlzma\txz --format=lzma\n";;
		'xz') printf "xz\txz\txz\n";;
		*) printf "$1\t$1\t$1\n";;
		esac
		shift
	done > ${TMPWORKINGDIRECTORY}/rootdir/etc/testcase-compressor.conf
}

forcecompressor() {
	COMPRESSOR="$1"
	COMPRESSOR_CMD="$1"
	case $COMPRESSOR in
	gzip) COMPRESS='gz';;
	bzip2) COMPRESS='bz2';;
	lzma) COMPRESS='lzma';;
	xz) COMPRESS='xz';;
	*) msgdie "Compressor $COMPRESSOR is unknown to framework, so can't be forced by forcecompressor!";;
	esac
	local CONFFILE="${TMPWORKINGDIRECTORY}/rootdir/etc/apt/apt.conf.d/00force-compressor"
	echo "Acquire::CompressionTypes::Order { \"${COMPRESS}\"; };
Dir::Bin::uncompressed \"/does/not/exist\";
Dir::Bin::gzip \"/does/not/exist\";
Dir::Bin::bzip2 \"/does/not/exist\";
Dir::Bin::lzma \"/does/not/exist\";
Dir::Bin::xz \"/does/not/exist\";" > "$CONFFILE"
	if [ -e "/bin/${COMPRESSOR}" ]; then
		echo "Dir::Bin::${COMPRESSOR} \"/bin/${COMPRESSOR}\";" >> "$CONFFILE"
	elif [ -e "/usr/bin/${COMPRESSOR}" ]; then
		echo "Dir::Bin::${COMPRESSOR} \"/usr/bin/${COMPRESSOR}\";" >> "$CONFFILE"
	elif [ "${COMPRESSOR}" = 'lzma' ]; then
		echo 'Dir::Bin::xz "/usr/bin/xz";' >> "$CONFFILE"
		COMPRESSOR_CMD='xz --format=lzma'
	else
		msgtest 'Test for availability of compressor' "${COMPRESSOR}"
		msgfail
	fi
}

setupsimplenativepackage() {
	local NAME="$1"
	local ARCH="$2"
	local VERSION="$3"
	local RELEASE="${4:-unstable}"
	local DEPENDENCIES="$5"
	local DESCRIPTION="${6:-"an autogenerated dummy ${NAME}=${VERSION}/${RELEASE}
 If you find such a package installed on your system,
 something went horribly wrong! They are autogenerated
 und used only by testcases and surf no other propose…"}"

	local SECTION="${7:-others}"
	local DISTSECTION
	if [ "$SECTION" = "$(echo "$SECTION" | cut -d'/' -f 2)" ]; then
		DISTSECTION="main"
	else
		DISTSECTION="$(echo "$SECTION" | cut -d'/' -f 1)"
	fi
	local BUILDDIR=incoming/${NAME}-${VERSION}
	mkdir -p ${BUILDDIR}/debian/source
	cd ${BUILDDIR}
	echo "* most suckless software product ever" > FEATURES
	test -e debian/copyright || echo "Copyleft by Joe Sixpack $(date +%Y)" > debian/copyright
	test -e debian/changelog || echo "$NAME ($VERSION) $RELEASE; urgency=low

  * Initial release

 -- Joe Sixpack <joe@example.org>  $(date -R)" > debian/changelog
	test -e debian/control || echo "Source: $NAME
Section: $SECTION
Priority: optional
Maintainer: Joe Sixpack <joe@example.org>
Build-Depends: debhelper (>= 7)
Standards-Version: 3.9.1

Package: $NAME" > debian/control
	if [ "$ARCH" = 'all' ]; then
		echo "Architecture: all" >> debian/control
	else
		echo "Architecture: any" >> debian/control
	fi
	test -z "$DEPENDENCIES" || echo "$DEPENDENCIES" >> debian/control
	echo "Description: $DESCRIPTION" >> debian/control

	test -e debian/compat || echo "7" > debian/compat
	test -e debian/source/format || echo "3.0 (native)" > debian/source/format
	test -e debian/rules || cp /usr/share/doc/debhelper/examples/rules.tiny debian/rules
	cd - > /dev/null
}

buildsimplenativepackage() {
	local NAME="$1"
	local ARCH="$2"
	local VERSION="$3"
	local RELEASE="${4:-unstable}"
	local DEPENDENCIES="$5"
	local DESCRIPTION="${6:-"an autogenerated dummy ${NAME}=${VERSION}/${RELEASE}
 If you find such a package installed on your system,
 something went horribly wrong! They are autogenerated
 und used only by testcases and surf no other propose…"}"

	local SECTION="${7:-others}"
	local PRIORITY="${8:-optional}"
        local FILE_TREE="$9"
        local COMPRESS_TYPE="${10:-gzip}"
	local DISTSECTION
	if [ "$SECTION" = "$(echo "$SECTION" | cut -d'/' -f 2)" ]; then
		DISTSECTION="main"
	else
		DISTSECTION="$(echo "$SECTION" | cut -d'/' -f 1)"
	fi
	local BUILDDIR=${TMPWORKINGDIRECTORY}/incoming/${NAME}-${VERSION}

	msgtest "Build source package in version ${VERSION} for ${RELEASE} in ${DISTSECTION}" "$NAME"
	mkdir -p $BUILDDIR/debian/source
	echo "* most suckless software product ever" > ${BUILDDIR}/FEATURES
	echo "#!/bin/sh
echo '$NAME says \"Hello!\"'" > ${BUILDDIR}/${NAME}

	echo "Copyleft by Joe Sixpack $(date +%Y)" > ${BUILDDIR}/debian/copyright
	echo "$NAME ($VERSION) $RELEASE; urgency=low

  * Initial release

 -- Joe Sixpack <joe@example.org>  $(date -R)" > ${BUILDDIR}/debian/changelog
	echo "Source: $NAME
Section: $SECTION
Priority: $PRIORITY
Maintainer: Joe Sixpack <joe@example.org>
Standards-Version: 3.9.3" > ${BUILDDIR}/debian/control
	local BUILDDEPS="$(echo "$DEPENDENCIES" | grep '^Build-')"
	test -z "$BUILDDEPS" || echo "$BUILDDEPS" >> ${BUILDDIR}/debian/control
	echo "
Package: $NAME" >> ${BUILDDIR}/debian/control

	if [ "$ARCH" = 'all' ]; then
		echo "Architecture: all" >> ${BUILDDIR}/debian/control
	else
		echo "Architecture: any" >> ${BUILDDIR}/debian/control
	fi
	local DEPS="$(echo "$DEPENDENCIES" | grep -v '^Build-')"
	test -z "$DEPS" || echo "$DEPS" >> ${BUILDDIR}/debian/control
	echo "Description: $DESCRIPTION" >> ${BUILDDIR}/debian/control

	echo '3.0 (native)' > ${BUILDDIR}/debian/source/format
	cd ${BUILDDIR}/..
	testsuccess --nomsg dpkg-source -b ${NAME}-${VERSION}
	cd - >/dev/null
	sed -n 's#^dpkg-source: info: building [^ ]\+ in ##p' ${TMPWORKINGDIRECTORY}/rootdir/tmp/testsuccess.output \
		| while read SRC; do
		echo "pool/${SRC}" >> ${BUILDDIR}/../${RELEASE}.${DISTSECTION}.srclist
#		if expr match "${SRC}" '.*\.dsc' >/dev/null 2>&1; then
#			aptkey --keyring ./keys/joesixpack.pub --secret-keyring ./keys/joesixpack.sec --quiet --readonly \
#				adv --yes --default-key 'Joe Sixpack' \
#				--clearsign -o "${BUILDDIR}/../${SRC}.sign" "${BUILDDIR}/../$SRC"
#			mv "${BUILDDIR}/../${SRC}.sign" "${BUILDDIR}/../$SRC"
#		fi
	done

	for arch in $(getarchitecturesfromcommalist "$ARCH"); do
		msgtest "Build binary package for ${RELEASE} in ${SECTION}" "$NAME"
		rm -rf ${BUILDDIR}/debian/tmp
		mkdir -p ${BUILDDIR}/debian/tmp/DEBIAN ${BUILDDIR}/debian/tmp/usr/share/doc/${NAME} ${BUILDDIR}/debian/tmp/usr/bin
		cp ${BUILDDIR}/debian/copyright ${BUILDDIR}/debian/changelog ${BUILDDIR}/FEATURES ${BUILDDIR}/debian/tmp/usr/share/doc/${NAME}
		cp ${BUILDDIR}/${NAME} ${BUILDDIR}/debian/tmp/usr/bin/${NAME}-${arch}
                if [ -n "$FILE_TREE" ]; then
                    cp -ar "$FILE_TREE" ${BUILDDIR}/debian/tmp
                fi

		(cd ${BUILDDIR}; dpkg-gencontrol -DArchitecture=$arch)
		(cd ${BUILDDIR}/debian/tmp; md5sum $(find usr/ -type f) > DEBIAN/md5sums)
		local LOG="${BUILDDIR}/../${NAME}_${VERSION}_${arch}.dpkg-deb.log"
		# ensure the right permissions as dpkg-deb ensists
		chmod 755 ${BUILDDIR}/debian/tmp/DEBIAN
		testsuccess --nomsg dpkg-deb -Z${COMPRESS_TYPE} --build ${BUILDDIR}/debian/tmp ${BUILDDIR}/..
		echo "pool/${NAME}_${VERSION}_${arch}.deb" >> ${BUILDDIR}/../${RELEASE}.${DISTSECTION}.pkglist
	done

	mkdir -p ${BUILDDIR}/../${NAME}_${VERSION}
	cp ${BUILDDIR}/debian/changelog ${BUILDDIR}/../${NAME}_${VERSION}/
	cp ${BUILDDIR}/debian/changelog ${BUILDDIR}/../${NAME}_${VERSION}.changelog
	rm -rf "${BUILDDIR}"
	msgdone "info"
}

buildpackage() {
	local BUILDDIR=$1
	local RELEASE=$2
	local SECTION=$3
	local ARCH=$(getarchitecture $4)
	local PKGNAME="$(echo "$BUILDDIR" | grep -o '[^/]*$')"
	local BUILDLOG="$(readlink -f "${BUILDDIR}/../${PKGNAME}_${RELEASE}_${SECTION}.dpkg-bp.log")"
	msgtest "Build package for ${RELEASE} in ${SECTION}" "$PKGNAME"
	cd $BUILDDIR
	if [ "$ARCH" = "all" ]; then
		ARCH="$(dpkg-architecture -qDEB_HOST_ARCH 2> /dev/null)"
	fi
	testsuccess --nomsg dpkg-buildpackage -uc -us -a$ARCH
	cp ${TMPWORKINGDIRECTORY}/rootdir/tmp/testsuccess.output $BUILDLOG
	local PKGS="$(grep '^dpkg-deb: building package' $BUILDLOG | cut -d'/' -f 2 | sed -e "s#'\.##")"
	local SRCS="$(grep '^dpkg-source: info: building' $BUILDLOG | grep -o '[a-z0-9._+~-]*$')"
	cd - > /dev/null
	for PKG in $PKGS; do
		echo "pool/${PKG}" >> ${TMPWORKINGDIRECTORY}/incoming/${RELEASE}.${SECTION}.pkglist
	done
	for SRC in $SRCS; do
		echo "pool/${SRC}" >> ${TMPWORKINGDIRECTORY}/incoming/${RELEASE}.${SECTION}.srclist
	done
}

buildaptarchive() {
	if [ -d incoming ]; then
		buildaptarchivefromincoming "$@"
	else
		buildaptarchivefromfiles "$@"
	fi
}

createaptftparchiveconfig() {
	local COMPRESSORS="$(cut -d'	' -f 1 ${TMPWORKINGDIRECTORY}/rootdir/etc/testcase-compressor.conf | tr '\n' ' ')"
	local COMPRESSORS="${COMPRESSORS%* }"
	local ARCHS="$(getarchitectures)"
	echo -n 'Dir {
	ArchiveDir "' >> ftparchive.conf
	echo -n $(readlink -f .) >> ftparchive.conf
	echo -n '";
	CacheDir "' >> ftparchive.conf
	echo -n $(readlink -f ..) >> ftparchive.conf
	echo -n '";
	FileListDir "' >> ftparchive.conf
	echo -n $(readlink -f pool/) >> ftparchive.conf
	echo -n '";
};
Default {
	Packages::Compress "'"$COMPRESSORS"'";
	Sources::Compress "'"$COMPRESSORS"'";
	Contents::Compress "'"$COMPRESSORS"'";
	Translation::Compress "'"$COMPRESSORS"'";
	LongDescription "false";
};
TreeDefault {
	Directory "pool/";
	SrcDirectory "pool/";
};
APT {
	FTPArchive {
		Release {
			Origin "joesixpack";
			Label "apttestcases";
			Suite "unstable";
			Description "repository with dummy packages";
			Architectures "' >> ftparchive.conf
	echo -n "$ARCHS" >> ftparchive.conf
	echo 'source";
		};
	};
};' >> ftparchive.conf
	for DIST in $(find ./pool/ -maxdepth 1 -name '*.pkglist' -type f | cut -d'/' -f 3 | cut -d'.' -f 1 | sort | uniq); do
		echo -n 'tree "dists/' >> ftparchive.conf
		echo -n "$DIST" >> ftparchive.conf
		echo -n '" {
	Architectures "' >> ftparchive.conf
		echo -n "$ARCHS" >> ftparchive.conf
		echo -n 'source";
	FileList "' >> ftparchive.conf
		echo -n "${DIST}.\$(SECTION).pkglist" >> ftparchive.conf
		echo -n '";
	SourceFileList "' >> ftparchive.conf
		echo -n "${DIST}.\$(SECTION).srclist" >> ftparchive.conf
		echo -n '";
	Sections "' >> ftparchive.conf
		echo -n "$(find ./pool/ -maxdepth 1 -name "${DIST}.*.pkglist" -type f | cut -d'/' -f 3 | cut -d'.' -f 2 | sort | uniq | tr '\n' ' ')" >> ftparchive.conf
		echo '";
};' >> ftparchive.conf
	done
}

buildaptftparchivedirectorystructure() {
	local DISTS="$(grep -i '^tree ' ftparchive.conf | cut -d'/' -f 2 | sed -e 's#".*##')"
	for DIST in $DISTS; do
		local SECTIONS="$(grep -i -A 5 "dists/$DIST" ftparchive.conf | grep -i 'Sections' | cut -d'"' -f 2)"
		for SECTION in $SECTIONS; do
			local ARCHS="$(grep -A 5 "dists/$DIST" ftparchive.conf | grep Architectures | cut -d'"' -f 2 | sed -e 's#source##')"
			for ARCH in $ARCHS; do
				mkdir -p dists/${DIST}/${SECTION}/binary-${ARCH}
			done
			mkdir -p dists/${DIST}/${SECTION}/source
			mkdir -p dists/${DIST}/${SECTION}/i18n
		done
	done
}

insertpackage() {
	local RELEASES="$1"
	local NAME="$2"
	local ARCH="$3"
	local VERSION="$4"
	local DEPENDENCIES="$5"
	local PRIORITY="${6:-optional}"
	local DESCRIPTION="${7:-"an autogenerated dummy ${NAME}=${VERSION}/${RELEASES}
 If you find such a package installed on your system,
 something went horribly wrong! They are autogenerated
 und used only by testcases and surf no other propose…"}"
	local ARCHS=""
	for RELEASE in $(printf '%s' "$RELEASES" | tr ',' '\n'); do
		if [ "$RELEASE" = 'installed' ]; then
			insertinstalledpackage "$2" "$3" "$4" "$5" "$6" "$7"
			continue
		fi
		for arch in $(getarchitecturesfromcommalist "$ARCH"); do
			if [ "$arch" = 'all' -o "$arch" = 'none' ]; then
				ARCHS="$(getarchitectures)"
			else
				ARCHS="$arch"
			fi
			for BUILDARCH in $ARCHS; do
				local PPATH="aptarchive/dists/${RELEASE}/main/binary-${BUILDARCH}"
				mkdir -p $PPATH
				local FILE="${PPATH}/Packages"
				echo "Package: $NAME
Priority: $PRIORITY
Section: other
Installed-Size: 42
Maintainer: Joe Sixpack <joe@example.org>" >> $FILE
				test "$arch" = 'none' || echo "Architecture: $arch" >> $FILE
				echo "Version: $VERSION
Filename: pool/main/${NAME}/${NAME}_${VERSION}_${arch}.deb" >> $FILE
				test -z "$DEPENDENCIES" || echo "$DEPENDENCIES" >> $FILE
				echo "Description: $(printf '%s' "$DESCRIPTION" | head -n 1)" >> $FILE
				echo "Description-md5: $(printf '%s' "$DESCRIPTION" | md5sum | cut -d' ' -f 1)" >> $FILE
				echo >> $FILE
			done
		done
		mkdir -p aptarchive/dists/${RELEASE}/main/source aptarchive/dists/${RELEASE}/main/i18n
		touch aptarchive/dists/${RELEASE}/main/source/Sources
		echo "Package: $NAME
Description-md5: $(printf '%s' "$DESCRIPTION" | md5sum | cut -d' ' -f 1)
Description-en: $DESCRIPTION
" >> aptarchive/dists/${RELEASE}/main/i18n/Translation-en
	done
}

insertsource() {
	local RELEASE="$1"
	local NAME="$2"
	local ARCH="$3"
	local VERSION="$4"
	local DEPENDENCIES="$5"
	local ARCHS=""
	local SPATH="aptarchive/dists/${RELEASE}/main/source"
	mkdir -p $SPATH
	local FILE="${SPATH}/Sources"
	echo "Package: $NAME
Binary: $NAME
Version: $VERSION
Maintainer: Joe Sixpack <joe@example.org>
Architecture: $ARCH" >> $FILE
	test -z "$DEPENDENCIES" || echo "$DEPENDENCIES" >> $FILE
	echo "Files:
 d41d8cd98f00b204e9800998ecf8427e 0 ${NAME}_${VERSION}.dsc
 d41d8cd98f00b204e9800998ecf8427e 0 ${NAME}_${VERSION}.tar.gz
" >> $FILE
}

insertinstalledpackage() {
	local NAME="$1"
	local ARCH="$2"
	local VERSION="$3"
	local DEPENDENCIES="$4"
	local PRIORITY="${5:-optional}"
	local STATUS="${6:-install ok installed}"
	local DESCRIPTION="${7:-"an autogenerated dummy ${NAME}=${VERSION}/installed
 If you find such a package installed on your system,
 something went horribly wrong! They are autogenerated
 und used only by testcases and surf no other propose…"}"

	local FILE='rootdir/var/lib/dpkg/status'
	local INFO='rootdir/var/lib/dpkg/info'
	for arch in $(getarchitecturesfromcommalist "$ARCH"); do
		echo "Package: $NAME
Status: $STATUS
Priority: $PRIORITY
Section: other
Installed-Size: 42
Maintainer: Joe Sixpack <joe@example.org>
Version: $VERSION" >> $FILE
		test "$arch" = 'none' || echo "Architecture: $arch" >> $FILE
		test -z "$DEPENDENCIES" || echo "$DEPENDENCIES" >> $FILE
		echo "Description: $DESCRIPTION" >> $FILE
		echo >> $FILE
		if [ "$(dpkg-query -W --showformat='${Multi-Arch}')" = 'same' ]; then
			echo -n > ${INFO}/${NAME}:${arch}.list
		else
			echo -n > ${INFO}/${NAME}.list
		fi
	done
}


buildaptarchivefromincoming() {
	msginfo "Build APT archive for ${CCMD}$(basename $0)${CINFO} based on incoming packages…"
	cd aptarchive
	[ -e pool ] || ln -s ../incoming pool
	[ -e ftparchive.conf ] || createaptftparchiveconfig
	[ -e dists ] || buildaptftparchivedirectorystructure
	msgninfo "\tGenerate Packages, Sources and Contents files… "
	testsuccess aptftparchive generate ftparchive.conf
	cd - > /dev/null
	msgdone "info"
	generatereleasefiles "$@"
}

buildaptarchivefromfiles() {
	msginfo "Build APT archive for ${CCMD}$(basename $0)${CINFO} based on prebuild files…"
	local DIR='aptarchive'
	if [ -d "${DIR}/dists" ]; then DIR="${DIR}/dists"; fi
	find "$DIR" -name 'Packages' -o -name 'Sources' -o -name 'Translation-*' | while read line; do
		msgninfo "\t${line} file… "
		compressfile "$line" "$1"
		msgdone "info"
	done
	generatereleasefiles "$@"
}

compressfile() {
	cat ${TMPWORKINGDIRECTORY}/rootdir/etc/testcase-compressor.conf | while read compressor extension command; do
		if [ "$compressor" = '.' ]; then
			if [ -n "$2" ]; then
				touch -d "$2" "$1"
			fi
			continue
		fi
		cat "$1" | $command > "${1}.${extension}"
		if [ -n "$2" ]; then
			touch -d "$2" "${1}.${extension}"
		fi
	done
}

# can be overridden by testcases for their pleasure
getcodenamefromsuite() {
	case "$1" in
	unstable) echo 'sid';;
	*) echo -n "$1";;
	esac
}
getreleaseversionfromsuite() { true; }
getlabelfromsuite() { true; }

generatereleasefiles() {
	# $1 is the Date header and $2 is the ValidUntil header to be set
	# both should be given in notation date/touch can understand
	msgninfo "\tGenerate Release files… "
	if [ -e aptarchive/dists ]; then
		for dir in $(find ./aptarchive/dists -mindepth 1 -maxdepth 1 -type d); do
			local SUITE="$(echo "$dir" | cut -d'/' -f 4)"
			local CODENAME="$(getcodenamefromsuite $SUITE)"
			local VERSION="$(getreleaseversionfromsuite $SUITE)"
			local LABEL="$(getlabelfromsuite $SUITE)"
			if [ -n "$VERSION" ]; then
				VERSION="-o APT::FTPArchive::Release::Version=${VERSION}"
			fi
			if [ -n "$LABEL" ]; then
				LABEL="-o APT::FTPArchive::Release::Label=${LABEL}"
			fi
			aptftparchive -qq release $dir \
				-o APT::FTPArchive::Release::Suite="${SUITE}" \
				-o APT::FTPArchive::Release::Codename="${CODENAME}" \
				${LABEL} \
				${VERSION} \
					| sed -e '/0 Release$/ d' > $dir/Release # remove the self reference
			if [ "$SUITE" = "experimental" -o "$SUITE" = "experimental2" ]; then
				sed -i '/^Date: / a\
NotAutomatic: yes' $dir/Release
			fi
			if [ -n "$1" -a "$1" != "now" ]; then
				sed -i "s/^Date: .*$/Date: $(date -d "$1" '+%a, %d %b %Y %H:%M:%S %Z')/" $dir/Release
			fi
			if [ -n "$2" ]; then
				sed -i "/^Date: / a\
Valid-Until: $(date -d "$2" '+%a, %d %b %Y %H:%M:%S %Z')" $dir/Release
			fi
		done
	else
		aptftparchive -qq release ./aptarchive | sed -e '/0 Release$/ d' > aptarchive/Release # remove the self reference
	fi
	if [ -n "$1" -a "$1" != "now" ]; then
		for release in $(find ./aptarchive -name 'Release'); do
			touch -d "$1" $release
		done
	fi
	msgdone "info"
}

setupdistsaptarchive() {
	local APTARCHIVE=$(readlink -f ./aptarchive)
	rm -f root/etc/apt/sources.list.d/apt-test-*-deb.list
	rm -f root/etc/apt/sources.list.d/apt-test-*-deb-src.list
	for DISTS in $(find ./aptarchive/dists/ -mindepth 1 -maxdepth 1 -type d | cut -d'/' -f 4); do
		SECTIONS=$(find ./aptarchive/dists/${DISTS}/ -mindepth 1 -maxdepth 1 -type d | cut -d'/' -f 5 | tr '\n' ' ')
		msgninfo "\tadd deb and deb-src sources.list lines for ${CCMD}${DISTS} ${SECTIONS}${CINFO}… "
		echo "deb file://$APTARCHIVE $DISTS $SECTIONS" > rootdir/etc/apt/sources.list.d/apt-test-${DISTS}-deb.list
		echo "deb-src file://$APTARCHIVE $DISTS $SECTIONS" > rootdir/etc/apt/sources.list.d/apt-test-${DISTS}-deb-src.list
		msgdone "info"
	done
}

setupflataptarchive() {
	local APTARCHIVE=$(readlink -f ./aptarchive)
	if [ -f ${APTARCHIVE}/Packages ]; then
		msgninfo "\tadd deb sources.list line… "
		echo "deb file://$APTARCHIVE /" > rootdir/etc/apt/sources.list.d/apt-test-archive-deb.list
		msgdone "info"
	else
		rm -f rootdir/etc/apt/sources.list.d/apt-test-archive-deb.list
	fi
	if [ -f ${APTARCHIVE}/Sources ]; then
		msgninfo "\tadd deb-src sources.list line… "
		echo "deb-src file://$APTARCHIVE /" > rootdir/etc/apt/sources.list.d/apt-test-archive-deb-src.list
		msgdone "info"
	else
		rm -f rootdir/etc/apt/sources.list.d/apt-test-archive-deb-src.list
	fi
}

setupaptarchive() {
	local NOUPDATE=0
	if [ "$1" = '--no-update' ]; then
		NOUPDATE=1
		shift
	fi
	buildaptarchive "$@"
	if [ -e aptarchive/dists ]; then
		setupdistsaptarchive
	else
		setupflataptarchive
	fi
	signreleasefiles 'Joe Sixpack'
	if [ "1" != "$NOUPDATE" ]; then
		testsuccess aptget update -o Debug::pkgAcquire::Worker=true -o Debug::Acquire::gpgv=true
	fi
}

signreleasefiles() {
	local SIGNER="${1:-Joe Sixpack}"
	local REPODIR="${2:-aptarchive}"
	local KEY="keys/$(echo "$SIGNER" | tr 'A-Z' 'a-z' | sed 's# ##g')"
	local GPG="aptkey --quiet --keyring ${KEY}.pub --secret-keyring ${KEY}.sec --readonly adv --batch --yes"
	msgninfo "\tSign archive with $SIGNER key $KEY… "
	local REXKEY='keys/rexexpired'
	local SECEXPIREBAK="${REXKEY}.sec.bak"
	local PUBEXPIREBAK="${REXKEY}.pub.bak"
	if [ "${SIGNER}" = 'Rex Expired' ]; then
		# the key is expired, so gpg doesn't allow to sign with and the --faked-system-time
		# option doesn't exist anymore (and using faketime would add a new obscure dependency)
		# therefore we 'temporary' make the key not expired and restore a backup after signing
		cp ${REXKEY}.sec $SECEXPIREBAK
		cp ${REXKEY}.pub $PUBEXPIREBAK
		local SECUNEXPIRED="${REXKEY}.sec.unexpired"
		local PUBUNEXPIRED="${REXKEY}.pub.unexpired"
		if [ -f "$SECUNEXPIRED" ] && [ -f "$PUBUNEXPIRED" ]; then
			cp $SECUNEXPIRED ${REXKEY}.sec
			cp $PUBUNEXPIRED ${REXKEY}.pub
		else
			if ! printf "expire\n1w\nsave\n" | $GPG --default-key "$SIGNER" --command-fd 0 --edit-key "${SIGNER}" >setexpire.gpg 2>&1; then
				cat setexpire.gpg
				exit 1
			fi
			cp ${REXKEY}.sec $SECUNEXPIRED
			cp ${REXKEY}.pub $PUBUNEXPIRED
		fi
	fi
	for RELEASE in $(find ${REPODIR}/ -name Release); do
		$GPG --default-key "$SIGNER" --armor --detach-sign --sign --output ${RELEASE}.gpg ${RELEASE}
		local INRELEASE="$(echo "${RELEASE}" | sed 's#/Release$#/InRelease#')"
		$GPG --default-key "$SIGNER" --clearsign --output $INRELEASE $RELEASE
		# we might have set a specific date for the Release file, so copy it
		touch -d "$(stat --format "%y" ${RELEASE})" ${RELEASE}.gpg ${INRELEASE}
	done
	if [ -f "$SECEXPIREBAK" ] && [ -f "$PUBEXPIREBAK" ]; then
		mv -f $SECEXPIREBAK ${REXKEY}.sec
		mv -f $PUBEXPIREBAK ${REXKEY}.pub
	fi
	msgdone "info"
}

redatereleasefiles() {
	local DATE="$(date -d "$1" '+%a, %d %b %Y %H:%M:%S %Z')"
	for release in $(find aptarchive/ -name 'Release'); do
		sed -i "s/^Date: .*$/Date: ${DATE}/" $release
		touch -d "$DATE" $release
	done
	signreleasefiles "${2:-Joe Sixpack}"
}

webserverconfig() {
	local WEBSERVER="${3:-http://localhost:8080}"
	local NOCHECK=false
	if [ "$1" = '--no-check' ]; then
		NOCHECK=true
		shift
	fi
	local DOWNLOG='rootdir/tmp/download-testfile.log'
	local STATUS='downloaded/webserverconfig.status'
	rm -f "$STATUS" "$DOWNLOG"
	local URI
	if [ -n "$2" ]; then
		msgtest "Set webserver config option '${1}' to" "$2"
		URI="${WEBSERVER}/_config/set/${1}/${2}"
	else
		msgtest 'Clear webserver config option' "${1}"
		URI="${WEBSERVER}/_config/clear/${1}"
	fi
	if downloadfile "$URI" "$STATUS" > "$DOWNLOG"; then
		msgpass
	else
		cat "$DOWNLOG" "$STATUS" || true
		msgfail
	fi
	$NOCHECK || testwebserverlaststatuscode '200'
}

rewritesourceslist() {
	local APTARCHIVE="file://$(readlink -f "${TMPWORKINGDIRECTORY}/aptarchive")"
	for LIST in $(find rootdir/etc/apt/sources.list.d/ -name 'apt-test-*.list'); do
		sed -i $LIST -e "s#$APTARCHIVE#${1}#" -e "s#http://localhost:8080/#${1}#" -e "s#https://localhost:4433/#${1}#"
	done
}

# wait for up to 10s for a pid file to appear to avoid possible race
# when a helper is started and dosn't write the PID quick enough
waitforpidfile() {
        local PIDFILE="$1"
        for i in $(seq 10); do
                if test -s "$PIDFILE"; then
                        return 0
                fi
                sleep 1
        done
        msgdie "waiting for $PIDFILE failed"
        return 1
}

changetowebserver() {
	if [ "$1" != '--no-rewrite' ]; then
		rewritesourceslist 'http://localhost:8080/'
	else
		shift
	fi
	if test -x ${APTWEBSERVERBINDIR}/aptwebserver; then
		cd aptarchive
		local LOG="webserver.log"
		if ! aptwebserver -o aptwebserver::fork=1 "$@" >$LOG 2>&1 ; then
			cat $LOG
			false
		fi
                waitforpidfile aptwebserver.pid
		local PID="$(cat aptwebserver.pid)"
		if [ -z "$PID" ]; then
			msgdie 'Could not fork aptwebserver successfully'
		fi
		addtrap "kill $PID;"
		cd - > /dev/null
	else
		msgdie 'You have to build aptwerbserver or install a webserver'
	fi
}

changetohttpswebserver() {
	if ! which stunnel4 >/dev/null; then
		msgdie 'You need to install stunnel4 for https testcases'
	fi
	if [ ! -e "${TMPWORKINGDIRECTORY}/aptarchive/aptwebserver.pid" ]; then
		changetowebserver --no-rewrite "$@"
	fi
	echo "pid = ${TMPWORKINGDIRECTORY}/aptarchive/stunnel.pid
cert = ${TMPWORKINGDIRECTORY}/rootdir/etc/webserver.pem
output = /dev/null

[https]
accept = 4433
connect = 8080
" > ${TMPWORKINGDIRECTORY}/stunnel.conf
	stunnel4 "${TMPWORKINGDIRECTORY}/stunnel.conf"
        waitforpidfile "${TMPWORKINGDIRECTORY}/aptarchive/stunnel.pid"
	local PID="$(cat ${TMPWORKINGDIRECTORY}/aptarchive/stunnel.pid)"
        if [ -z "$PID" ]; then
		msgdie 'Could not fork stunnel4 successfully'
	fi
	addtrap 'prefix' "kill ${PID};"
	rewritesourceslist 'https://localhost:4433/'
}

changetocdrom() {
	mkdir -p rootdir/media/cdrom/.disk
	local CD="$(readlink -f rootdir/media/cdrom)"
	echo "acquire::cdrom::mount \"${CD}\";
acquire::cdrom::${CD}/::mount \"mv ${CD}-unmounted ${CD}\";
acquire::cdrom::${CD}/::umount \"mv ${CD} ${CD}-unmounted\";
acquire::cdrom::autodetect 0;" > rootdir/etc/apt/apt.conf.d/00cdrom
	echo -n "$1" > ${CD}/.disk/info
	if [ ! -d aptarchive/dists ]; then
		msgdie 'Flat file archive cdroms can not be created currently'
		return 1
	fi
	mv aptarchive/dists "$CD"
	ln -s "$(readlink -f ./incoming)" $CD/pool
	find rootdir/etc/apt/sources.list.d/ -name 'apt-test-*.list' -delete
	# start with an unmounted disk
	mv "${CD}" "${CD}-unmounted"
	# we don't want the disk to be modifiable
	addtrap 'prefix' "chmod -f -R +w $PWD/rootdir/media/cdrom/dists/ $PWD/rootdir/media/cdrom-unmounted/dists/ || true;"
	chmod -R 555 rootdir/media/cdrom-unmounted/dists
}

downloadfile() {
	local PROTO="${1%%:*}"
	if ! apthelper -o Debug::Acquire::${PROTO}=1 -o Debug::pkgAcquire::Worker=1 \
		download-file "$1" "$2" "$3" 2>&1 ; then
		return 1
	fi
	# only if the file exists the download was successful
	if [ -r "$2" ]; then
		return 0
	else
		return 1
	fi
}

checkdiff() {
	local DIFFTEXT="$(command diff -u "$@" 2>&1 | sed -e '/^---/ d' -e '/^+++/ d' -e '/^@@/ d')"
	if [ -n "$DIFFTEXT" ]; then
		echo >&2
		echo >&2 "$DIFFTEXT"
		return 1
	else
		return 0
	fi
}

testfileequal() {
	local FILE="$1"
	shift
	msgtest "Test for correctness of file" "$FILE"
	if [ -z "$*" ]; then
		echo -n "" | checkdiff - $FILE && msgpass || msgfail
	else
		echo "$*" | checkdiff - $FILE && msgpass || msgfail
	fi
}

testempty() {
	msgtest "Test for no output of" "$*"
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testempty.comparefile"
	if "$@" >$COMPAREFILE 2>&1 && test ! -s $COMPAREFILE; then
		msgpass
	else
		echo
		cat $COMPAREFILE
		msgfail
	fi
	aptautotest 'testempty' "$@"
}

testequal() {
	local MSG='Test of equality of'
	if [ "$1" = '--nomsg' ]; then
		MSG=''
		shift
	fi

	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequal.comparefile"
	echo "$1" > $COMPAREFILE
	shift

	if [ -n "$MSG" ]; then
		msgtest "$MSG" "$*"
	fi
	"$@" 2>&1 | checkdiff $COMPAREFILE - && msgpass || msgfail
	aptautotest 'testequal' "$@"
}

testequalor2() {
	local COMPAREFILE1="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.comparefile1"
	local COMPAREFILE2="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.comparefile2"
	local COMPAREAGAINST="${TMPWORKINGDIRECTORY}/rootdir/tmp/testequalor2.compareagainst"
	echo "$1" > $COMPAREFILE1
	echo "$2" > $COMPAREFILE2
	shift 2
	msgtest "Test for equality OR of" "$*"
	"$@" >$COMPAREAGAINST 2>&1 || true
	if checkdiff $COMPAREFILE1 $COMPAREAGAINST >/dev/null 2>&1 || \
		checkdiff $COMPAREFILE2 $COMPAREAGAINST >/dev/null 2>&1
	then
		msgpass
	else
		echo -n "\n${CINFO}Diff against OR 1${CNORMAL}"
		checkdiff $COMPAREFILE1 $COMPAREAGAINST || true
		echo -n "${CINFO}Diff against OR 2${CNORMAL}"
		checkdiff $COMPAREFILE2 $COMPAREAGAINST || true
		msgfail
	fi
	aptautotest 'testequalor2' "$@"
}

testshowvirtual() {
	local VIRTUAL="N: Can't select versions from package '$1' as it is purely virtual"
	local PACKAGE="$1"
	shift
	while [ -n "$1" ]; do
		VIRTUAL="${VIRTUAL}
N: Can't select versions from package '$1' as it is purely virtual"
		PACKAGE="${PACKAGE} $1"
		shift
	done
	msgtest "Test for virtual packages" "apt-cache show $PACKAGE"
	VIRTUAL="${VIRTUAL}
N: No packages found"
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testshowvirtual.comparefile"
	local ARCH="$(getarchitecture 'native')"
	echo "$VIRTUAL" | sed -e "s/:$ARCH//" -e 's/:all//' > $COMPAREFILE
	aptcache show -q=0 $PACKAGE 2>&1 | checkdiff $COMPAREFILE - && msgpass || msgfail
}

testnopackage() {
	msgtest "Test for non-existent packages" "apt-cache show $*"
	local SHOWPKG="$(aptcache show "$@" 2>&1 | grep '^Package: ')"
	if [ -n "$SHOWPKG" ]; then
		echo >&2
		echo >&2 "$SHOWPKG"
		msgfail
	else
		msgpass
	fi
}

testdpkgstatus() {
	local STATE="$1"
	local NR="$2"
	shift 2
	msgtest "Test that $NR package(s) are in state $STATE with" "dpkg -l $*"
	local PKGS="$(dpkg -l "$@" 2>/dev/null | grep "^${STATE}" | wc -l)"
	if [ "$PKGS" != $NR ]; then
		echo >&2 $PKGS
		dpkg -l "$@" | grep '^[a-z]' >&2
		msgfail
	else
		msgpass
	fi
}

testdpkginstalled() {
	testdpkgstatus 'ii' "$#" "$@"
}

testdpkgnotinstalled() {
	testdpkgstatus 'ii' '0' "$@"
}

testmarkedauto() {
	local COMPAREFILE="${TMPWORKINGDIRECTORY}/rootdir/tmp/testmarkedauto.comparefile"
	if [ -n "$1" ]; then
		msgtest 'Test for correctly marked as auto-installed' "$*"
		while [ -n "$1" ]; do echo "$1"; shift; done | sort > $COMPAREFILE
	else
		msgtest 'Test for correctly marked as auto-installed' 'no package'
		echo -n > $COMPAREFILE
	fi
	aptmark showauto 2>&1 | checkdiff $COMPAREFILE - && msgpass || msgfail
}

msgfailoutput() {
	local MSG="$1"
	local OUTPUT="$2"
	shift 2
	echo >&2
	if [ "$1" = 'grep' ]; then
		while [ -n "$2" ]; do shift; done
		echo "#### Complete file: $1 ####"
		cat >&2 "$1" || true
		echo '#### grep output ####'
	elif [ "$1" = 'test' ]; then
		# doesn't support ! or non-file flags
		msgfailoutputstatfile() {
			local FILEFLAGS='^-[bcdefgGhkLOprsStuwx]$'
			if expr match "$1" "$FILEFLAGS" >/dev/null; then
				echo "#### stat(2) of file: $2 ####"
				stat "$2" || true
			fi
		}
		msgfailoutputstatfile "$2" "$3"
		while [ -n "$5" ] && [ "$4" = '-o' -o "$4" = '-a' ]; do
			shift 3
			msgfailoutputstatfile "$2" "$3"
		done
		echo '#### test output ####'
	fi
	cat >&2 $OUTPUT
	msgfail "$MSG"
}

testsuccess() {
	if [ "$1" = '--nomsg' ]; then
		shift
	else
		msgtest 'Test for successful execution of' "$*"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testsuccess.output"
	if "$@" >${OUTPUT} 2>&1; then
		if expr match "$1" '^apt.*' >/dev/null; then
			if grep -q -E ' runtime error: ' "$OUTPUT"; then
				msgfailoutput 'compiler detected undefined behavior' "$OUTPUT" "$@"
			elif grep -q -E '^[WE]: ' "$OUTPUT"; then
				msgfailoutput 'successful run, but output contains warnings/errors' "$OUTPUT" "$@"
			else
				msgpass
			fi
		else
			msgpass
		fi
	else
		local EXITCODE=$?
		msgfailoutput "exitcode $EXITCODE" "$OUTPUT" "$@"
	fi
	aptautotest 'testsuccess' "$@"
}
testwarning() {
	if [ "$1" = '--nomsg' ]; then
		shift
	else
		msgtest 'Test for successful execution with warnings of' "$*"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testwarning.output"
	if "$@" >${OUTPUT} 2>&1; then
		if expr match "$1" '^apt.*' >/dev/null; then
			if grep -q -E ' runtime error: ' "$OUTPUT"; then
				msgfailoutput 'compiler detected undefined behavior' "$OUTPUT" "$@"
			elif grep -q -E '^E: ' "$OUTPUT"; then
				msgfailoutput 'successful run, but output contains errors' "$OUTPUT" "$@"
			elif ! grep -q -E '^W: ' "$OUTPUT"; then
				msgfailoutput 'successful run, but output contains no warnings' "$OUTPUT" "$@"
			else
				msgpass
			fi
		else
			msgpass
		fi
	else
		local EXITCODE=$?
		echo >&2
		cat >&2 $OUTPUT
		msgfail "exitcode $EXITCODE"
	fi
	aptautotest 'testwarning' "$@"
}
testfailure() {
	if [ "$1" = '--nomsg' ]; then
		shift
	else
		msgtest 'Test for failure in execution of' "$*"
	fi
	local OUTPUT="${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailure.output"
	if "$@" >${OUTPUT} 2>&1; then
		local EXITCODE=$?
		msgfailoutput "exitcode $EXITCODE" "$OUTPUT" "$@"
	else
		local EXITCODE=$?
		if expr match "$1" '^apt.*' >/dev/null; then
			if grep -q -E ' runtime error: ' "$OUTPUT"; then
				msgfailoutput 'compiler detected undefined behavior' "$OUTPUT" "$@"
			elif ! grep -q -E '^E: ' "$OUTPUT"; then
				msgfailoutput "run failed with exitcode ${EXITCODE}, but with no errors" "$OUTPUT" "$@"
			else
				msgpass
			fi
		else
			msgpass
		fi
	fi
	aptautotest 'testfailure' "$@"
}

testsuccessequal() {
	local CMP="$1"
	shift
	testsuccess "$@"
	testfileequal "${TMPWORKINGDIRECTORY}/rootdir/tmp/testsuccess.output" "$CMP"
}
testwarningequal() {
	local CMP="$1"
	shift
	testwarning "$@"
	testfileequal "${TMPWORKINGDIRECTORY}/rootdir/tmp/testwarning.output" "$CMP"
}
testfailureequal() {
	local CMP="$1"
	shift
	testfailure "$@"
	testfileequal "${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailure.output" "$CMP"
}

testfailuremsg() {
	local CMP="$1"
	shift
	testfailure "$@"
	msgtest 'Check that the output of the previous failed command has expected' 'failures and warnings'
	grep '^\(W\|E\):' "${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailure.output" > "${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailureequal.output" 2>&1 || true
	if echo "$CMP" | checkdiff - "${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailureequal.output"; then
		msgpass
	else
		echo '### Complete output ###'
		cat "${TMPWORKINGDIRECTORY}/rootdir/tmp/testfailure.output"
		msgfail
	fi
}

testfilestats() {
	msgtest "Test that file $1 has $2 $3" "$4"
	if [ "$4" "$3" "$(stat --format "$2" "$1")" ]; then
		msgpass
	else
		echo >&2
		ls -ld >&2 "$1"
		echo -n >&2 "stat(1) reports for $2: "
		stat --format "$2" "$1"
		msgfail
	fi
}
testaccessrights() {
	testfilestats "$1" '%a' '=' "$2"
}

testwebserverlaststatuscode() {
	local DOWNLOG='rootdir/tmp/webserverstatus-testfile.log'
	local STATUS='downloaded/webserverstatus-statusfile.log'
	rm -f "$DOWNLOG" "$STATUS"
	msgtest 'Test last status code from the webserver was' "$1"
	if downloadfile "http://localhost:8080/_config/find/aptwebserver::last-status-code" "$STATUS" > "$DOWNLOG" && [ "$(cat "$STATUS")" = "$1" ]; then
		msgpass
	else
		echo >&2
		if [ -n "$2" ]; then
			shift
			echo >&2 '#### Additionally provided output files contain:'
			cat >&2 "$@"
		fi
		echo >&2 '#### Download log of the status code:'
		cat >&2 "$DOWNLOG"
		msgfail "Status was $(cat "$STATUS")"
	fi
}

pause() {
	echo "STOPPED execution. Press enter to continue"
	local IGNORE
	read IGNORE
}

listcurrentlistsdirectory() {
	{
		find rootdir/var/lib/apt/lists -maxdepth 1 -type d | while read line; do
			stat --format '%U:%G:%a:%n' "$line"
		done
		find rootdir/var/lib/apt/lists -maxdepth 1 \! -type d | while read line; do
			stat --format '%U:%G:%a:%s:%y:%n' "$line"
		done
	} | sort
}

### convinience hacks ###
mkdir() {
	# creating some directories by hand is a tedious task, so make it look simple
	if [ "$*" = '-p rootdir/var/lib/apt/lists' ] || [ "$*" = "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists" ] ||
	   [ "$*" = '-p rootdir/var/lib/apt/lists/partial' ] || [ "$*" = "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/partial" ]; then
		# only the last directory created by mkdir is effected by the -m !
		command mkdir -m 755 -p "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt"
		command mkdir -m 755 -p "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists"
		command mkdir -m 700 -p "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/partial"
		touch "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/lock"
		if [ "$(id -u)" = '0' ]; then
			chown _apt:root "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/partial"
		fi
	else
		command mkdir "$@"
	fi
}

### The following tests are run by most test methods automatically to check
### general things about commands executed without writing the test every time.

aptautotest() {
	local TESTCALL="$1"
	local CMD="$2"
	local FIRSTOPT="$3"
	local AUTOTEST="aptautotest_$(basename "$CMD" | tr -d '-')_$(echo "$FIRSTOPT" | tr -d '-')"
	if command -v $AUTOTEST >/dev/null; then
		shift 3
		# save and restore the *.output files from other tests
		# as we might otherwise override them in these automatic tests
		rm -rf ${TMPWORKINGDIRECTORY}/rootdir/tmp-before
		mv ${TMPWORKINGDIRECTORY}/rootdir/tmp ${TMPWORKINGDIRECTORY}/rootdir/tmp-before
		mkdir ${TMPWORKINGDIRECTORY}/rootdir/tmp
		$AUTOTEST "$TESTCALL" "$@"
		rm -rf ${TMPWORKINGDIRECTORY}/rootdir/tmp-aptautotest
		mv ${TMPWORKINGDIRECTORY}/rootdir/tmp ${TMPWORKINGDIRECTORY}/rootdir/tmp-aptautotest
		mv ${TMPWORKINGDIRECTORY}/rootdir/tmp-before ${TMPWORKINGDIRECTORY}/rootdir/tmp
	fi
}

aptautotest_aptget_update() {
	if ! test -d "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists"; then return; fi
	testfilestats "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt" '%U:%G:%a' '=' "${TEST_DEFAULT_USER}:${TEST_DEFAULT_GROUP}:755"
	testfilestats "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists" '%U:%G:%a' '=' "${TEST_DEFAULT_USER}:${TEST_DEFAULT_GROUP}:755"
	# all copied files are properly chmodded
	for file in $(find "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists" -type f ! -name 'lock'); do
		testfilestats "$file" '%U:%G:%a' '=' "${TEST_DEFAULT_USER}:${TEST_DEFAULT_GROUP}:644"
	done
	if [ "$1" = 'testsuccess' ]; then
		# failure cases can retain partial files and such
		testempty find "${TMPWORKINGDIRECTORY}/rootdir/var/lib/apt/lists/partial" -mindepth 1 ! \( -name 'lock' -o -name '*.FAILED' \)
	fi
}
aptautotest_apt_update() { aptautotest_aptget_update "$@"; }
aptautotest_aptcdrom_add() { aptautotest_aptget_update "$@"; }

testaptautotestnodpkgwarning() {
	local TESTCALL="$1"
	while [ -n "$2" ]; do
		if expr match "$2" '^-[a-z]*s' >/dev/null 2>&1; then return; fi # simulation mode
		if expr match "$2" '^-dy\?' >/dev/null 2>&1; then return; fi # download-only mode
		shift
	done
	testfailure grep '^dpkg: warning:.*ignor.*' "${TMPWORKINGDIRECTORY}/rootdir/tmp-before/${TESTCALL}.output"
}

aptautotest_aptget_install() { testaptautotestnodpkgwarning "$@"; }
aptautotest_aptget_remove() { testaptautotestnodpkgwarning "$@"; }
aptautotest_aptget_purge() { testaptautotestnodpkgwarning "$@"; }
aptautotest_apt_install() { testaptautotestnodpkgwarning "$@"; }
aptautotest_apt_remove() { testaptautotestnodpkgwarning "$@"; }
aptautotest_apt_purge() { testaptautotestnodpkgwarning "$@"; }
